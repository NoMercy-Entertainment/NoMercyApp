const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/shadow-css-CC-OvL_A.js","assets/index-CymNhKD_.js","assets/index-BBsLWdlE.css"])))=>i.map(i=>d[i]);
import{Ct as at,Gn as ds,wt as fs}from"./index-CymNhKD_.js";var n,us,hs=ds(()=>{n={allRenderFn:!1,cmpDidLoad:!0,cmpDidUnload:!1,cmpDidUpdate:!0,cmpDidRender:!0,cmpWillLoad:!0,cmpWillUpdate:!0,cmpWillRender:!0,connectedCallback:!0,disconnectedCallback:!0,element:!0,event:!0,hasRenderFn:!0,lifecycle:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,formAssociated:!1,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,constructableCSS:!0,cmpShouldUpdate:!0,devTools:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!1,asyncQueue:!1,transformTagName:!1,attachStyles:!0,experimentalSlotFixes:!1},us="app"});function ps(e){var t,s,i;return(i=(s=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:s.getAttribute("content"))!=null?i:void 0}function gs(e,t){if(e.isOk){const s=t(e.value);return s instanceof Promise?s.then(i=>pe(i)):pe(s)}if(e.isErr){const s=e.value;return rt(s)}throw"should never get here"}function ct(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var $t,dt,ge,me,b,ft,ye,ms,_,ve,U,R,Se,ut,M,be,ht,pt,gt,mt,V,xe,Te,yt,Le,vt,E,m,ys,p,vs,D,St,bt,xt,ee,B,W,N,te,_e,ke,Ce,q,X,Ss,Tt,bs,we,Lt,_t,kt,se,pe,rt,Ct,wt,Dt,k,Nt,De,O,At,ne,Et,Ne,Ot,It,jt,ie,oe,zt,xs,Ts,Rt,Pt,Ls,le,Ae,Ht,re,Ft,Ee,Oe,Ut,Ie,je,Mt,ze,P,Re,w,H,K,Q,x,G,Pe,F,He,Fe,Bt,Y,ae,Ue,I,J,C,Me,Be,We,v,qe,ce,Xe,Wt,qt,Ke,Z,Xt,Qe,Kt,Qt,Ge,Ye,Je,_s,Gt,L,j,Ze,Ve,Yt,Jt,et,tt,$e,Zt,Vt,de,es,ts,st,nt,ss,ns,is,os,ls,rs,it,ot,fe,lt,z,ue,ks,he,as,cs,$s,ws=ds(()=>{hs(),fs(),$t=Object.defineProperty,dt=(e,t)=>{for(var s in t)$t(e,s,{get:t[s],enumerable:!0})},ge={isDev:!!n.isDev,isBrowser:!0,isServer:!1,isTesting:!!n.isTesting},me=n.hotModuleReplacement?window.__STENCIL_HOSTREFS__||(window.__STENCIL_HOSTREFS__=new WeakMap):new WeakMap,b=e=>me.get(e),ft=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return n.isDev&&(s.$renderCount$=0),n.method&&n.lazyLoad&&(s.$onInstancePromise$=new Promise(i=>s.$onInstanceResolve$=i)),n.asyncLoading&&(s.$onReadyPromise$=new Promise(i=>s.$onReadyResolve$=i),e["s-p"]=[],e["s-rc"]=[]),me.set(e,s)},ye=(e,t)=>t in e,_=(e,t)=>(ms||console.error)(e,t),ve=n.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],U=(...e)=>console.error(...ve,...e),R=(...e)=>console.warn(...ve,...e),Se=new Map,ut=(e,t,s)=>{const i=e.$tagName$.replace(/-/g,"_"),o=e.$lazyBundleId$;if(n.isDev&&typeof o!="string"){U(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);return}else if(!o)return;const l=n.hotModuleReplacement?!1:Se.get(o);return l?l[i]:at(()=>import(`./${o}.entry.js${n.hotModuleReplacement&&s?"?s-hmr="+s:""}`),[]).then(a=>(n.hotModuleReplacement||Se.set(o,a),a[i]),_)},M=new Map,be=[],ht="r",pt="o",gt="s",mt="t",V="s-id",xe="sty-id",Te="c-id",yt="slot-fb{display:contents}slot-fb[hidden]{display:none}",Le="http://www.w3.org/1999/xlink",vt=["formAssociatedCallback","formResetCallback","formDisabledCallback","formStateRestoreCallback"],E=typeof window<"u"?window:{},m=E.document||{head:{}},ys=E.HTMLElement||class{},p={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,i)=>e.addEventListener(t,s,i),rel:(e,t,s,i)=>e.removeEventListener(t,s,i),ce:(e,t)=>new CustomEvent(e,t)},vs=e=>{Object.assign(p,e)},D=n.shadowDom,St=(()=>{let e=!1;try{m.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch{}return e})(),bt=e=>Promise.resolve(e),xt=n.constructableCSS?(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})():!1,ee=0,B=!1,W=[],N=[],te=[],_e=(e,t)=>s=>{e.push(s),B||(B=!0,t&&p.$flags$&4?X(q):p.raf(q))},ke=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){_(s)}e.length=0},Ce=(e,t)=>{let s=0,i=0;for(;s<e.length&&(i=performance.now())<t;)try{e[s++](i)}catch(o){_(o)}s===e.length?e.length=0:s!==0&&e.splice(0,s)},q=()=>{if(n.asyncQueue&&ee++,ke(W),n.asyncQueue){const e=(p.$flags$&6)===2?performance.now()+14*Math.ceil(ee*.1):1/0;Ce(N,e),Ce(te,e),N.length>0&&(te.push(...N),N.length=0),(B=W.length+N.length+te.length>0)?p.raf(q):ee=0}else ke(N),(B=W.length>0)&&p.raf(q)},X=e=>bt().then(e),Ss=_e(W,!1),Tt=_e(N,!0),bs=e=>{const t=new URL(e,p.$resourcesUrl$);return t.origin!==E.location.origin?t.href:t.pathname},we={},Lt="http://www.w3.org/2000/svg",_t="http://www.w3.org/1999/xhtml",kt=e=>e!=null,se=e=>(e=typeof e,e==="object"||e==="function"),dt({},{err:()=>rt,map:()=>gs,ok:()=>pe,unwrap:()=>Ct,unwrapErr:()=>wt}),pe=e=>({isOk:!0,isErr:!1,value:e}),rt=e=>({isOk:!1,isErr:!0,value:e}),Ct=e=>{if(e.isOk)return e.value;throw e.value},wt=e=>{if(e.isErr)return e.value;throw e.value},Dt=0,k=(e,t="")=>{if(n.profile&&performance.mark){const s=`st:${e}:${t}:${Dt++}`;return performance.mark(s),()=>performance.measure(`[Stencil] ${e}() <${t}>`,s)}else return()=>{}},Nt=(e,t)=>n.profile&&performance.mark?(performance.getEntriesByName(e,"mark").length===0&&performance.mark(e),()=>{performance.getEntriesByName(t,"measure").length===0&&performance.measure(t,e)}):()=>{},De=(e,t,...s)=>{let i=null,o=null,l=null,a=!1,c=!1;const r=[],$=f=>{for(let u=0;u<f.length;u++)i=f[u],Array.isArray(i)?$(i):i!=null&&typeof i!="boolean"&&((a=typeof e!="function"&&!se(i))?i=String(i):n.isDev&&typeof e!="function"&&i.$flags$===void 0&&U(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`),a&&c?r[r.length-1].$text$+=i:r.push(a?O(null,i):i),c=a)};if($(s),t&&(n.isDev&&e==="input"&&It(t),n.vdomKey&&t.key&&(o=t.key),n.slotRelocation&&t.name&&(l=t.name),n.vdomClass)){const f=t.className||t.class;f&&(t.class=typeof f!="object"?f:Object.keys(f).filter(u=>f[u]).join(" "))}if(n.isDev&&r.some(ne)&&U(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`),n.vdomFunctional&&typeof e=="function")return e(t===null?{}:t,r,Et);const d=O(e,null);return d.$attrs$=t,r.length>0&&(d.$children$=r),n.vdomKey&&(d.$key$=o),n.slotRelocation&&(d.$name$=l),d},O=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return n.vdomAttribute&&(s.$attrs$=null),n.vdomKey&&(s.$key$=null),n.slotRelocation&&(s.$name$=null),s},At={},ne=e=>e&&e.$tag$===At,Et={forEach:(e,t)=>e.map(Ne).forEach(t),map:(e,t)=>e.map(Ne).map(t).map(Ot)},Ne=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),Ot=e=>{if(typeof e.vtag=="function"){const s={...e.vattrs};return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),De(e.vtag,s,...e.vchildren||[])}const t=O(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},It=e=>{const t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;const i=t.indexOf("type"),o=t.indexOf("min"),l=t.indexOf("max"),a=t.indexOf("step");(s<i||s<o||s<l||s<a)&&R('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},jt=(e,t,s,i)=>{const o=k("hydrateClient",t),l=e.shadowRoot,a=[],c=[],r=n.shadowDom&&l?[]:null,$=i.$vnode$=O(t,null);p.$orgLocNodes$||oe(m.body,p.$orgLocNodes$=new Map),e[V]=s,e.removeAttribute(V),ie($,a,c,r,e,e,s),a.map(d=>{const f=d.$hostId$+"."+d.$nodeId$,u=p.$orgLocNodes$.get(f),h=d.$elm$;u&&D&&u["s-en"]===""&&u.parentNode.insertBefore(h,u.nextSibling),l||(h["s-hn"]=t,u&&(h["s-ol"]=u,h["s-ol"]["s-nr"]=h)),p.$orgLocNodes$.delete(f)}),n.shadowDom&&l&&r.map(d=>{d&&l.appendChild(d)}),o()},ie=(e,t,s,i,o,l,a)=>{let c,r,$,d;if(l.nodeType===1){if(c=l.getAttribute(Te),c&&(r=c.split("."),(r[0]===a||r[0]==="0")&&($={$flags$:0,$hostId$:r[0],$nodeId$:r[1],$depth$:r[2],$index$:r[3],$tag$:l.tagName.toLowerCase(),$elm$:l,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null},t.push($),l.removeAttribute(Te),e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$,e=$,i&&$.$depth$==="0"&&(i[$.$index$]=$.$elm$))),l.shadowRoot)for(d=l.shadowRoot.childNodes.length-1;d>=0;d--)ie(e,t,s,i,o,l.shadowRoot.childNodes[d],a);for(d=l.childNodes.length-1;d>=0;d--)ie(e,t,s,i,o,l.childNodes[d],a)}else if(l.nodeType===8)r=l.nodeValue.split("."),(r[1]===a||r[1]==="0")&&(c=r[0],$={$flags$:0,$hostId$:r[1],$nodeId$:r[2],$depth$:r[3],$index$:r[4],$elm$:l,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null},c===mt?($.$elm$=l.nextSibling,$.$elm$&&$.$elm$.nodeType===3&&($.$text$=$.$elm$.textContent,t.push($),l.remove(),e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$,i&&$.$depth$==="0"&&(i[$.$index$]=$.$elm$))):$.$hostId$===a&&(c===gt?($.$tag$="slot",r[5]?l["s-sn"]=$.$name$=r[5]:l["s-sn"]="",l["s-sr"]=!0,n.shadowDom&&i&&($.$elm$=m.createElement($.$tag$),$.$name$&&$.$elm$.setAttribute("name",$.$name$),l.parentNode.insertBefore($.$elm$,l),l.remove(),$.$depth$==="0"&&(i[$.$index$]=$.$elm$)),s.push($),e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$):c===ht&&(n.shadowDom&&i?l.remove():n.slotRelocation&&(o["s-cr"]=l,l["s-cn"]=!0))));else if(e&&e.$tag$==="style"){const f=O(null,l.textContent);f.$elm$=l,f.$index$="0",e.$children$=[f]}},oe=(e,t)=>{if(e.nodeType===1){let s=0;if(e.shadowRoot)for(;s<e.shadowRoot.childNodes.length;s++)oe(e.shadowRoot.childNodes[s],t);for(s=0;s<e.childNodes.length;s++)oe(e.childNodes[s],t)}else if(e.nodeType===8){const s=e.nodeValue.split(".");s[0]===pt&&(t.set(s[1]+"."+s[2],e),e.nodeValue="",e["s-en"]=s[3])}},zt=e=>be.map(t=>t(e)).find(t=>!!t),xs=e=>be.push(e),Ts=e=>b(e).$modeName$,Rt=(e,t)=>e!=null&&!se(e)?n.propBoolean&&t&4?e==="false"?!1:e===""||!!e:n.propNumber&&t&2?parseFloat(e):n.propString&&t&1?String(e):e:e,Pt=e=>n.lazyLoad?b(e).$hostElement$:e,Ls=(e,t,s)=>{const i=Pt(e);return{emit:o=>(n.isDev&&!i.isConnected&&R(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),le(i,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:o}))}},le=(e,t,s)=>{const i=p.ce(t,s);return e.dispatchEvent(i),i},Ae=new WeakMap,Ht=(e,t,s)=>{let i=M.get(e);xt&&s?(i=i||new CSSStyleSheet,typeof i=="string"?i=t:i.replaceSync(t)):i=t,M.set(e,i)},re=(e,t,s)=>{var i;const o=Ee(t,s),l=M.get(o);if(!n.attachStyles)return o;if(e=e.nodeType===11?e:m,l)if(typeof l=="string"){e=e.head||e;let a=Ae.get(e),c;if(a||Ae.set(e,a=new Set),!a.has(o)){if(n.hydrateClientSide&&e.host&&(c=e.querySelector(`[${xe}="${o}"]`)))c.innerHTML=l;else{c=m.createElement("style"),c.innerHTML=l;const r=(i=p.$nonce$)!=null?i:ps(m);r!=null&&c.setAttribute("nonce",r),(n.hydrateServerSide||n.hotModuleReplacement)&&t.$flags$&2&&c.setAttribute(xe,o),(!(t.$flags$&1)||t.$flags$&1&&e.nodeName!=="HEAD")&&e.insertBefore(c,e.querySelector("link"))}t.$flags$&4&&(c.innerHTML+=yt),a&&a.add(o)}}else n.constructableCSS&&!e.adoptedStyleSheets.includes(l)&&(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return o},Ft=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,i=t.$flags$,o=k("attachStyles",t.$tagName$),l=re(n.shadowDom&&D&&s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);(n.shadowDom||n.scoped)&&n.cssAnnotations&&i&10&&i&2&&(s["s-sc"]=l,s.classList.add(l+"-h"),n.scoped&&i&2&&s.classList.add(l+"-s")),o()},Ee=(e,t)=>"sc-"+(n.mode&&t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$),Oe=(e,t,s,i,o,l)=>{if(s!==i){let a=ye(e,t),c=t.toLowerCase();if(n.vdomClass&&t==="class"){const r=e.classList,$=Ie(s),d=Ie(i);r.remove(...$.filter(f=>f&&!d.includes(f))),r.add(...d.filter(f=>f&&!$.includes(f)))}else if(n.vdomStyle&&t==="style"){if(n.updatable)for(const r in s)(!i||i[r]==null)&&(!n.hydrateServerSide&&r.includes("-")?e.style.removeProperty(r):e.style[r]="");for(const r in i)(!s||i[r]!==s[r])&&(!n.hydrateServerSide&&r.includes("-")?e.style.setProperty(r,i[r]):e.style[r]=i[r])}else if(!(n.vdomKey&&t==="key")){if(n.vdomRef&&t==="ref")i&&i(e);else if(n.vdomListener&&(n.lazyLoad?!a:!e.__lookupSetter__(t))&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"?t=t.slice(3):ye(E,c)?t=c.slice(2):t=c[2]+t.slice(3),s||i){const r=t.endsWith(je);t=t.replace(Mt,""),s&&p.rel(e,t,s,r),i&&p.ael(e,t,i,r)}}else if(n.vdomPropOrAttr){const r=se(i);if((a||r&&i!==null)&&!o)try{if(e.tagName.includes("-"))e[t]=i;else{const d=i??"";t==="list"?a=!1:(s==null||e[t]!=d)&&(e[t]=d)}}catch{}let $=!1;n.vdomXlink&&c!==(c=c.replace(/^xlink\:?/,""))&&(t=c,$=!0),i==null||i===!1?(i!==!1||e.getAttribute(t)==="")&&(n.vdomXlink&&$?e.removeAttributeNS(Le,t):e.removeAttribute(t)):(!a||l&4||o)&&!r&&(i=i===!0?"":i,n.vdomXlink&&$?e.setAttributeNS(Le,t,i):e.setAttribute(t,i))}}}},Ut=/\s/,Ie=e=>e?e.split(Ut):[],je="Capture",Mt=new RegExp(je+"$"),ze=(e,t,s)=>{const i=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,o=e&&e.$attrs$||we,l=t.$attrs$||we;if(n.updatable)for(const a of ct(Object.keys(o)))a in l||Oe(i,a,o[a],void 0,s,t.$flags$);for(const a of ct(Object.keys(l)))Oe(i,a,o[a],l[a],s,t.$flags$)},H=!1,K=!1,Q=!1,x=!1,G=(e,t,s,i)=>{var o;const l=t.$children$[s];let a=0,c,r,$;if(n.slotRelocation&&!H&&(Q=!0,l.$tag$==="slot"&&(P&&i.classList.add(P+"-s"),l.$flags$|=l.$children$?2:1)),n.isDev&&l.$elm$&&U(`The JSX ${l.$text$!==null?`"${l.$text$}" text`:`"${l.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),n.vdomText&&l.$text$!==null)c=l.$elm$=m.createTextNode(l.$text$);else if(n.slotRelocation&&l.$flags$&1)c=l.$elm$=n.isDebug||n.hydrateServerSide?Wt(l):m.createTextNode("");else{if(n.svg&&!x&&(x=l.$tag$==="svg"),c=l.$elm$=n.svg?m.createElementNS(x?Lt:_t,!H&&n.slotRelocation&&l.$flags$&2?"slot-fb":l.$tag$):m.createElement(!H&&n.slotRelocation&&l.$flags$&2?"slot-fb":l.$tag$),n.svg&&x&&l.$tag$==="foreignObject"&&(x=!1),n.vdomAttribute&&ze(null,l,x),c.getRootNode().querySelector("body")&&n.scoped&&kt(P)&&c["s-si"]!==P&&c.classList.add(c["s-si"]=P),n.scoped&&ce(c,i),l.$children$)for(a=0;a<l.$children$.length;++a)r=G(e,l,a,c),r&&c.appendChild(r);n.svg&&(l.$tag$==="svg"?x=!1:c.tagName==="foreignObject"&&(x=!0))}return c["s-hn"]=w,n.slotRelocation&&l.$flags$&3&&(c["s-sr"]=!0,c["s-cr"]=Re,c["s-sn"]=l.$name$||"",c["s-rf"]=(o=l.$attrs$)==null?void 0:o.ref,$=e&&e.$children$&&e.$children$[s],$&&$.$tag$===l.$tag$&&e.$elm$&&(n.experimentalSlotFixes?Pe(e.$elm$):F(e.$elm$,!1))),c},Pe=e=>{p.$flags$|=1;const t=e.closest(w.toLowerCase());if(t!=null){const s=Array.from(t.childNodes).find(o=>o["s-cr"]),i=Array.from(e.childNodes);for(const o of s?i.reverse():i)o["s-sh"]!=null&&(v(t,o,s??null),o["s-sh"]=void 0,Q=!0)}p.$flags$&=-2},F=(e,t)=>{p.$flags$|=1;const s=Array.from(e.childNodes);if(e["s-sr"]&&n.experimentalSlotFixes){let i=e;for(;i=i.nextSibling;)i&&i["s-sn"]===e["s-sn"]&&i["s-sh"]===w&&s.push(i)}for(let i=s.length-1;i>=0;i--){const o=s[i];o["s-hn"]!==w&&o["s-ol"]&&(v(Ue(o),o,ae(o)),o["s-ol"].remove(),o["s-ol"]=void 0,o["s-sh"]=void 0,Q=!0),t&&F(o,t)}p.$flags$&=-2},He=(e,t,s,i,o,l)=>{let a=n.slotRelocation&&e["s-cr"]&&e["s-cr"].parentNode||e,c;for(n.shadowDom&&a.shadowRoot&&a.tagName===w&&(a=a.shadowRoot);o<=l;++o)i[o]&&(c=G(null,s,o,e),c&&(i[o].$elm$=c,v(a,c,n.slotRelocation?ae(t):t)))},Fe=(e,t,s)=>{for(let i=t;i<=s;++i){const o=e[i];if(o){const l=o.$elm$;We(o),l&&(n.slotRelocation&&(K=!0,l["s-ol"]?l["s-ol"].remove():F(l,!0)),l.remove())}}},Bt=(e,t,s,i,o=!1)=>{let l=0,a=0,c=0,r=0,$=t.length-1,d=t[0],f=t[$],u=i.length-1,h=i[0],g=i[u],T,y;for(;l<=$&&a<=u;)if(d==null)d=t[++l];else if(f==null)f=t[--$];else if(h==null)h=i[++a];else if(g==null)g=i[--u];else if(Y(d,h,o))I(d,h,o),d=t[++l],h=i[++a];else if(Y(f,g,o))I(f,g,o),f=t[--$],g=i[--u];else if(Y(d,g,o))n.slotRelocation&&(d.$tag$==="slot"||g.$tag$==="slot")&&F(d.$elm$.parentNode,!1),I(d,g,o),v(e,d.$elm$,f.$elm$.nextSibling),d=t[++l],g=i[--u];else if(Y(f,h,o))n.slotRelocation&&(d.$tag$==="slot"||g.$tag$==="slot")&&F(f.$elm$.parentNode,!1),I(f,h,o),v(e,f.$elm$,d.$elm$),f=t[--$],h=i[++a];else{if(c=-1,n.vdomKey){for(r=l;r<=$;++r)if(t[r]&&t[r].$key$!==null&&t[r].$key$===h.$key$){c=r;break}}n.vdomKey&&c>=0?(y=t[c],y.$tag$!==h.$tag$?T=G(t&&t[a],s,c,e):(I(y,h,o),t[c]=void 0,T=y.$elm$),h=i[++a]):(T=G(t&&t[a],s,a,e),h=i[++a]),T&&(n.slotRelocation?v(Ue(d.$elm$),T,ae(d.$elm$)):v(d.$elm$.parentNode,T,d.$elm$))}l>$?He(e,i[u+1]==null?null:i[u+1].$elm$,s,i,a,u):n.updatable&&a>u&&Fe(t,l,$)},Y=(e,t,s=!1)=>e.$tag$===t.$tag$?n.slotRelocation&&e.$tag$==="slot"?"$nodeId$"in e&&s&&e.$elm$.nodeType!==8?!1:e.$name$===t.$name$:n.vdomKey&&!s?e.$key$===t.$key$:!0:!1,ae=e=>e&&e["s-ol"]||e,Ue=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,I=(e,t,s=!1)=>{const i=t.$elm$=e.$elm$,o=e.$children$,l=t.$children$,a=t.$tag$,c=t.$text$;let r;!n.vdomText||c===null?(n.svg&&(x=a==="svg"?!0:a==="foreignObject"?!1:x),(n.vdomAttribute||n.reflect)&&(n.slot&&a==="slot"&&!H?n.experimentalSlotFixes&&e.$name$!==t.$name$&&(t.$elm$["s-sn"]=t.$name$||"",Pe(t.$elm$.parentElement)):ze(e,t,x)),n.updatable&&o!==null&&l!==null?Bt(i,o,t,l,s):l!==null?(n.updatable&&n.vdomText&&e.$text$!==null&&(i.textContent=""),He(i,null,t,l,0,l.length-1)):!s&&n.updatable&&o!==null&&Fe(o,0,o.length-1),n.svg&&x&&a==="svg"&&(x=!1)):n.vdomText&&n.slotRelocation&&(r=i["s-cr"])?r.parentNode.textContent=c:n.vdomText&&e.$text$!==c&&(i.data=c)},J=e=>{const t=e.childNodes;for(const s of t)if(s.nodeType===1){if(s["s-sr"]){const i=s["s-sn"];s.hidden=!1;for(const o of t)if(o!==s){if(o["s-hn"]!==s["s-hn"]||i!==""){if(o.nodeType===1&&(i===o.getAttribute("slot")||i===o["s-sn"])||o.nodeType===3&&i===o["s-sn"]){s.hidden=!0;break}}else if(o.nodeType===1||o.nodeType===3&&o.textContent.trim()!==""){s.hidden=!0;break}}}J(s)}},C=[],Me=e=>{let t,s,i;for(const o of e.childNodes){if(o["s-sr"]&&(t=o["s-cr"])&&t.parentNode){s=t.parentNode.childNodes;const l=o["s-sn"];for(i=s.length-1;i>=0;i--)if(t=s[i],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==o["s-hn"]&&(!n.experimentalSlotFixes||!t["s-sh"]||t["s-sh"]!==o["s-hn"]))if(Be(t,l)){let a=C.find(c=>c.$nodeToRelocate$===t);K=!0,t["s-sn"]=t["s-sn"]||l,a?(a.$nodeToRelocate$["s-sh"]=o["s-hn"],a.$slotRefNode$=o):(t["s-sh"]=o["s-hn"],C.push({$slotRefNode$:o,$nodeToRelocate$:t})),t["s-sr"]&&C.map(c=>{Be(c.$nodeToRelocate$,t["s-sn"])&&(a=C.find(r=>r.$nodeToRelocate$===t),a&&!c.$slotRefNode$&&(c.$slotRefNode$=a.$slotRefNode$))})}else C.some(a=>a.$nodeToRelocate$===t)||C.push({$nodeToRelocate$:t})}o.nodeType===1&&Me(o)}},Be=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",We=e=>{n.vdomRef&&(e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(We))},v=(e,t,s)=>{const i=e?.insertBefore(t,s);return n.scoped&&ce(t,e),i},qe=e=>{const t=[];return e&&t.push(...e["s-scs"]||[],e["s-si"],e["s-sc"],...qe(e.parentElement)),t},ce=(e,t,s=!1)=>{var i;if(e&&t&&e.nodeType===1){const o=new Set(qe(t).filter(Boolean));if(o.size&&((i=e.classList)==null||i.add(...e["s-scs"]=[...o]),e["s-ol"]||s))for(const l of Array.from(e.childNodes))ce(l,e,!0)}},Xe=(e,t,s=!1)=>{var i,o,l,a,c;const r=e.$hostElement$,$=e.$cmpMeta$,d=e.$vnode$||O(null,null),f=ne(t)?t:De(null,null,t);if(w=r.tagName,n.isDev&&Array.isArray(t)&&t.some(ne))throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${w.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);if(n.reflect&&$.$attrsToReflect$&&(f.$attrs$=f.$attrs$||{},$.$attrsToReflect$.map(([u,h])=>f.$attrs$[h]=r[u])),s&&f.$attrs$)for(const u of Object.keys(f.$attrs$))r.hasAttribute(u)&&!["key","ref","style","class"].includes(u)&&(f.$attrs$[u]=r[u]);if(f.$tag$=null,f.$flags$|=4,e.$vnode$=f,f.$elm$=d.$elm$=n.shadowDom&&r.shadowRoot||r,(n.scoped||n.shadowDom)&&(P=r["s-sc"]),H=D&&($.$flags$&1)!==0,n.slotRelocation&&(Re=r["s-cr"],K=!1),I(d,f,s),n.slotRelocation){if(p.$flags$|=1,Q){Me(f.$elm$);for(const u of C){const h=u.$nodeToRelocate$;if(!h["s-ol"]){const g=n.isDebug||n.hydrateServerSide?qt(h):m.createTextNode("");g["s-nr"]=h,v(h.parentNode,h["s-ol"]=g,h)}}for(const u of C){const h=u.$nodeToRelocate$,g=u.$slotRefNode$;if(g){const T=g.parentNode;let y=g.nextSibling;if(!n.experimentalSlotFixes||y&&y.nodeType===1){let A=(i=h["s-ol"])==null?void 0:i.previousSibling;for(;A;){let S=(o=A["s-nr"])!=null?o:null;if(S&&S["s-sn"]===h["s-sn"]&&T===S.parentNode){for(S=S.nextSibling;S===h||S?.["s-sr"];)S=S?.nextSibling;if(!S||!S["s-nr"]){y=S;break}}A=A.previousSibling}}(!y&&T!==h.parentNode||h.nextSibling!==y)&&h!==y&&(!n.experimentalSlotFixes&&!h["s-hn"]&&h["s-ol"]&&(h["s-hn"]=h["s-ol"].parentNode.nodeName),v(T,h,y),h.nodeType===1&&(h.hidden=(l=h["s-ih"])!=null?l:!1)),h&&typeof g["s-rf"]=="function"&&g["s-rf"](h)}else h.nodeType===1&&(s&&(h["s-ih"]=(a=h.hidden)!=null?a:!1),h.hidden=!0)}}K&&J(f.$elm$),p.$flags$&=-2,C.length=0}if(n.experimentalScopedSlotChanges&&$.$flags$&2)for(const u of f.$elm$.childNodes)u["s-hn"]!==w&&!u["s-sh"]&&(s&&u["s-ih"]==null&&(u["s-ih"]=(c=u.hidden)!=null?c:!1),u.hidden=!0);Re=void 0},Wt=e=>m.createComment(`<slot${e.$name$?' name="'+e.$name$+'"':""}> (host=${w.toLowerCase()})`),qt=e=>m.createComment("org-location for "+(e.localName?`<${e.localName}> (host=${e["s-hn"]})`:`[${e.textContent}]`)),Ke=(e,t)=>{n.asyncLoading&&t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},Z=(e,t)=>{if(n.taskQueue&&n.updatable&&(e.$flags$|=16),n.asyncLoading&&e.$flags$&4){e.$flags$|=512;return}Ke(e,e.$ancestorComponent$);const s=()=>Xt(e,t);return n.taskQueue?Tt(s):s()},Xt=(e,t)=>{const s=e.$hostElement$,i=k("scheduleUpdate",e.$cmpMeta$.$tagName$),o=n.lazyLoad?e.$lazyInstance$:s;if(!o)throw new Error(`Can't render component <${s.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let l;return t?(n.lazyLoad&&n.hostListener&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map(([a,c])=>L(o,a,c)),e.$queuedListeners$=void 0)),j(s,"componentWillLoad"),n.cmpWillLoad&&(l=L(o,"componentWillLoad"))):(j(s,"componentWillUpdate"),n.cmpWillUpdate&&(l=L(o,"componentWillUpdate"))),j(s,"componentWillRender"),n.cmpWillRender&&(l=Qe(l,()=>L(o,"componentWillRender"))),i(),Qe(l,()=>Qt(e,o,t))},Qe=(e,t)=>Kt(e)?e.then(t).catch(s=>{console.error(s),t()}):t(),Kt=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",Qt=async(e,t,s)=>{var i;const o=e.$hostElement$,l=k("update",e.$cmpMeta$.$tagName$),a=o["s-rc"];n.style&&s&&Ft(e);const c=k("render",e.$cmpMeta$.$tagName$);if(n.isDev&&(e.$flags$|=1024),n.hydrateServerSide?await Ye(e,t,o,s):Ye(e,t,o,s),n.isDev&&(e.$renderCount$=e.$renderCount$===void 0?1:e.$renderCount$+1,e.$flags$&=-1025),n.hydrateServerSide)try{Ve(o),s&&(e.$cmpMeta$.$flags$&1?o["s-en"]="":e.$cmpMeta$.$flags$&2&&(o["s-en"]="c"))}catch(r){_(r,o)}if(n.asyncLoading&&a&&(a.map(r=>r()),o["s-rc"]=void 0),c(),l(),n.asyncLoading){const r=(i=o["s-p"])!=null?i:[],$=()=>Je(e);r.length===0?$():(Promise.all(r).then($),e.$flags$|=4,r.length=0)}else Je(e)},Ge=null,Ye=(e,t,s,i)=>{const o=!!n.allRenderFn,l=!!n.lazyLoad,a=!!n.taskQueue,c=!!n.updatable;try{if(Ge=t,t=(o||t.render)&&t.render(),c&&a&&(e.$flags$&=-17),(c||l)&&(e.$flags$|=2),n.hasRenderFn||n.reflect)if(n.vdomRender||n.reflect){if(n.hydrateServerSide)return Promise.resolve(t).then(r=>Xe(e,r,i));Xe(e,t,i)}else{const r=s.shadowRoot;e.$cmpMeta$.$flags$&1?r.textContent=t:s.textContent=t}}catch(r){_(r,e.$hostElement$)}return Ge=null,null},Je=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,i=k("postUpdate",t),o=n.lazyLoad?e.$lazyInstance$:s,l=e.$ancestorComponent$;n.cmpDidRender&&(n.isDev&&(e.$flags$|=1024),L(o,"componentDidRender"),n.isDev&&(e.$flags$&=-1025)),j(s,"componentDidRender"),e.$flags$&64?(n.cmpDidUpdate&&(n.isDev&&(e.$flags$|=1024),L(o,"componentDidUpdate"),n.isDev&&(e.$flags$&=-1025)),j(s,"componentDidUpdate"),i()):(e.$flags$|=64,n.asyncLoading&&n.cssAnnotations&&Ze(s),n.cmpDidLoad&&(n.isDev&&(e.$flags$|=2048),L(o,"componentDidLoad"),n.isDev&&(e.$flags$&=-2049)),j(s,"componentDidLoad"),i(),n.asyncLoading&&(e.$onReadyResolve$(s),l||Gt(t))),n.method&&n.lazyLoad&&e.$onInstanceResolve$(s),n.asyncLoading&&(e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&X(()=>Z(e,!1)),e.$flags$&=-517)},_s=e=>{if(n.updatable&&(ge.isBrowser||ge.isTesting)){const t=b(e),s=t.$hostElement$.isConnected;return s&&(t.$flags$&18)===2&&Z(t,!1),s}return!1},Gt=e=>{n.cssAnnotations&&Ze(m.documentElement),n.asyncQueue&&(p.$flags$|=2),X(()=>le(E,"appload",{detail:{namespace:"app"}})),n.profile&&performance.measure&&performance.measure(`[Stencil] app initial load (by ${e})`,"st:app:start")},L=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(i){_(i)}},j=(e,t)=>{n.lifecycleDOMEvents&&le(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:"app"}})},Ze=e=>{var t,s;return n.hydratedClass?e.classList.add((t=n.hydratedSelectorName)!=null?t:"hydrated"):n.hydratedAttribute?e.setAttribute((s=n.hydratedSelectorName)!=null?s:"hydrated",""):void 0},Ve=e=>{const t=e.children;if(t!=null)for(let s=0,i=t.length;s<i;s++){const o=t[s];typeof o.connectedCallback=="function"&&o.connectedCallback(),Ve(o)}},Yt=(e,t)=>b(e).$instanceValues$.get(t),Jt=(e,t,s,i)=>{const o=b(e);if(n.lazyLoad&&!o)throw new Error(`Couldn't find host element for "${i.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);const l=n.lazyLoad?o.$hostElement$:e,a=o.$instanceValues$.get(t),c=o.$flags$,r=n.lazyLoad?o.$lazyInstance$:l;s=Rt(s,i.$members$[t][0]);const $=s!==a&&!(Number.isNaN(a)&&Number.isNaN(s));if((!n.lazyLoad||!(c&8)||a===void 0)&&$&&(o.$instanceValues$.set(t,s),n.isDev&&(o.$flags$&1024?R(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,`
Element`,l,`
New value`,s,`
Old value`,a):o.$flags$&2048&&R(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,`
Element`,l,`
New value`,s,`
Old value`,a)),!n.lazyLoad||r)){if(n.watchCallback&&i.$watchers$&&c&128){const d=i.$watchers$[t];d&&d.map(f=>{try{r[f](s,a,t)}catch(u){_(u,l)}})}if(n.updatable&&(c&18)===2){if(n.cmpShouldUpdate&&r.componentShouldUpdate&&r.componentShouldUpdate(s,a,t)===!1)return;Z(o,!1)}}},et=(e,t,s)=>{var i,o;const l=e.prototype;if(n.formAssociated&&t.$flags$&64&&s&1&&vt.forEach(a=>Object.defineProperty(l,a,{value(...c){const r=b(this),$=n.lazyLoad?r.$hostElement$:this,d=n.lazyLoad?r.$lazyInstance$:$;if(!d)r.$onReadyPromise$.then(f=>{const u=f[a];typeof u=="function"&&u.call(f,...c)});else{const f=d[a];typeof f=="function"&&f.call(d,...c)}}})),n.member&&t.$members$||n.watchCallback&&(t.$watchers$||e.watchers)){n.watchCallback&&e.watchers&&!t.$watchers$&&(t.$watchers$=e.watchers);const a=Object.entries((i=t.$members$)!=null?i:{});if(a.map(([c,[r]])=>{(n.prop||n.state)&&(r&31||(!n.lazyLoad||s&2)&&r&32)?Object.defineProperty(l,c,{get(){return Yt(this,c)},set($){if(n.isDev){const d=b(this);!(s&1)&&(d&&d.$flags$&8)===0&&r&31&&!(r&1024)&&R(`@Prop() "${c}" on <${t.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`)}Jt(this,c,$,t)},configurable:!0,enumerable:!0}):n.lazyLoad&&n.method&&s&1&&r&64&&Object.defineProperty(l,c,{value(...$){var d;const f=b(this);return(d=f?.$onInstancePromise$)==null?void 0:d.then(()=>{var u;return(u=f.$lazyInstance$)==null?void 0:u[c](...$)})}})}),n.observeAttribute&&(!n.lazyLoad||s&1)){const c=new Map;l.attributeChangedCallback=function(r,$,d){p.jmp(()=>{var f;const u=c.get(r);if(this.hasOwnProperty(u))d=this[u],delete this[u];else{if(l.hasOwnProperty(u)&&typeof this[u]=="number"&&this[u]==d)return;if(u==null){const h=b(this),g=h?.$flags$;if(g&&!(g&8)&&g&128&&d!==$){const T=n.lazyLoad?h.$hostElement$:this,y=n.lazyLoad?h.$lazyInstance$:T;((f=t.$watchers$)==null?void 0:f[r])?.forEach(A=>{y[A]!=null&&y[A].call(y,d,$,r)})}return}}this[u]=d===null&&typeof this[u]=="boolean"?!1:d})},e.observedAttributes=Array.from(new Set([...Object.keys((o=t.$watchers$)!=null?o:{}),...a.filter(([r,$])=>$[0]&15).map(([r,$])=>{var d;const f=$[1]||r;return c.set(f,r),n.reflect&&$[0]&512&&((d=t.$attrsToReflect$)==null||d.push([r,f])),f})]))}}return e},tt=async(e,t,s,i)=>{let o;if(!(t.$flags$&32)){t.$flags$|=32;const c=s.$lazyBundleId$;if((n.lazyLoad||n.hydrateClientSide)&&c){const r=ut(s,t,i);if(r&&"then"in r){const d=Nt(`st:load:${s.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${s.$tagName$}>`);o=await r,d()}else o=r;if(!o)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);n.member&&!o.isProxied&&(n.watchCallback&&(s.$watchers$=o.watchers),et(o,s,2),o.isProxied=!0);const $=k("createInstance",s.$tagName$);n.member&&(t.$flags$|=8);try{new o(t)}catch(d){_(d)}n.member&&(t.$flags$&=-9),n.watchCallback&&(t.$flags$|=128),$(),$e(t.$lazyInstance$)}else{o=e.constructor;const r=e.localName;customElements.whenDefined(r).then(()=>t.$flags$|=128)}if(n.style&&o&&o.style){let r;typeof o.style=="string"?r=o.style:n.mode&&typeof o.style!="string"&&(t.$modeName$=zt(e),t.$modeName$&&(r=o.style[t.$modeName$]),n.hydrateServerSide&&t.$modeName$&&e.setAttribute("s-mode",t.$modeName$));const $=Ee(s,t.$modeName$);if(!M.has($)){const d=k("registerStyles",s.$tagName$);!n.hydrateServerSide&&n.shadowDom&&n.shadowDomShim&&s.$flags$&8&&(r=await at(()=>import("./shadow-css-CC-OvL_A.js"),__vite__mapDeps([0,1,2])).then(f=>f.scopeCss(r,$))),Ht($,r,!!(s.$flags$&1)),d()}}}const l=t.$ancestorComponent$,a=()=>Z(t,!0);n.asyncLoading&&l&&l["s-rc"]?l["s-rc"].push(a):a()},$e=e=>{n.lazyLoad&&n.connectedCallback&&L(e,"connectedCallback")},Zt=e=>{if(!(p.$flags$&1)){const t=b(e),s=t.$cmpMeta$,i=k("connectedCallback",s.$tagName$);if(n.hostListenerTargetParent&&he(e,t,s.$listeners$,!0),t.$flags$&1)he(e,t,s.$listeners$,!1),t?.$lazyInstance$?$e(t.$lazyInstance$):t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>$e(t.$lazyInstance$));else{t.$flags$|=1;let o;if(n.hydrateClientSide&&(o=e.getAttribute(V),o)){if(n.shadowDom&&D&&s.$flags$&1){const l=n.mode?re(e.shadowRoot,s,e.getAttribute("s-mode")):re(e.shadowRoot,s);e.classList.remove(l+"-h",l+"-s")}jt(e,s.$tagName$,o,t)}if(n.slotRelocation&&!o&&(n.hydrateServerSide||(n.slot||n.shadowDom)&&s.$flags$&12)&&Vt(e),n.asyncLoading){let l=e;for(;l=l.parentNode||l.host;)if(n.hydrateClientSide&&l.nodeType===1&&l.hasAttribute("s-id")&&l["s-p"]||l["s-p"]){Ke(t,t.$ancestorComponent$=l);break}}n.prop&&!n.hydrateServerSide&&s.$members$&&Object.entries(s.$members$).map(([l,[a]])=>{if(a&31&&e.hasOwnProperty(l)){const c=e[l];delete e[l],e[l]=c}}),n.initializeNextTick?X(()=>tt(e,t,s)):tt(e,t,s)}i()}},Vt=e=>{const t=e["s-cr"]=m.createComment(n.isDebug?`content-ref (host=${e.localName})`:"");t["s-cn"]=!0,v(e,t,e.firstChild)},de=e=>{n.lazyLoad&&n.disconnectedCallback&&L(e,"disconnectedCallback"),n.cmpDidUnload&&L(e,"componentDidUnload")},es=async e=>{if(!(p.$flags$&1)){const t=b(e);n.hostListener&&t.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0),n.lazyLoad?t?.$lazyInstance$?de(t.$lazyInstance$):t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>de(t.$lazyInstance$)):de(e)}},ts=(e,t)=>{st(e),nt(e),is(e),ns(e),rs(e),os(e),ls(e),it(e),ot(e,t),ss(e)},st=e=>{const t=e.cloneNode;e.cloneNode=function(s){const i=this,o=n.shadowDom?i.shadowRoot&&D:!1,l=t.call(i,o?s:!1);if(n.slot&&!o&&s){let a=0,c,r;const $=["s-id","s-cr","s-lr","s-rc","s-sc","s-p","s-cn","s-sr","s-sn","s-hn","s-ol","s-nr","s-si","s-rf","s-scs"];for(;a<i.childNodes.length;a++)c=i.childNodes[a]["s-nr"],r=$.every(d=>!i.childNodes[a][d]),c&&(n.appendChildSlotFix&&l.__appendChild?l.__appendChild(c.cloneNode(!0)):l.appendChild(c.cloneNode(!0))),r&&l.appendChild(i.childNodes[a].cloneNode(!0))}return l}},nt=e=>{e.__appendChild=e.appendChild,e.appendChild=function(t){const s=t["s-sn"]=lt(t),i=z(this.childNodes,s,this.tagName);if(i){const o=ue(i,s),l=o[o.length-1],a=v(l.parentNode,t,l.nextSibling);return J(this),a}return this.__appendChild(t)}},ss=e=>{e.__removeChild=e.removeChild,e.removeChild=function(t){if(t&&typeof t["s-sn"]<"u"){const s=z(this.childNodes,t["s-sn"],this.tagName);if(s){const i=ue(s,t["s-sn"]).find(o=>o===t);if(i){i.remove(),J(this);return}}}return this.__removeChild(t)}},ns=e=>{const t=e.prepend;e.prepend=function(...s){s.forEach(i=>{typeof i=="string"&&(i=this.ownerDocument.createTextNode(i));const o=i["s-sn"]=lt(i),l=z(this.childNodes,o,this.tagName);if(l){const a=document.createTextNode("");a["s-nr"]=i,l["s-cr"].parentNode.__appendChild(a),i["s-ol"]=a;const c=ue(l,o)[0];return v(c.parentNode,i,c.nextSibling)}return i.nodeType===1&&i.getAttribute("slot")&&(i.hidden=!0),t.call(this,i)})}},is=e=>{e.append=function(...t){t.forEach(s=>{typeof s=="string"&&(s=this.ownerDocument.createTextNode(s)),this.appendChild(s)})}},os=e=>{const t=e.insertAdjacentHTML;e.insertAdjacentHTML=function(s,i){if(s!=="afterbegin"&&s!=="beforeend")return t.call(this,s,i);const o=this.ownerDocument.createElement("_");let l;if(o.innerHTML=i,s==="afterbegin")for(;l=o.firstChild;)this.prepend(l);else if(s==="beforeend")for(;l=o.firstChild;)this.append(l)}},ls=e=>{e.insertAdjacentText=function(t,s){this.insertAdjacentHTML(t,s)}},rs=e=>{const t=e.insertAdjacentElement;e.insertAdjacentElement=function(s,i){return s!=="afterbegin"&&s!=="beforeend"?t.call(this,s,i):s==="afterbegin"?(this.prepend(i),i):(s==="beforeend"&&this.append(i),i)}},it=e=>{const t=Object.getOwnPropertyDescriptor(Node.prototype,"textContent");Object.defineProperty(e,"__textContent",t),n.experimentalScopedSlotChanges?Object.defineProperty(e,"textContent",{get(){return" "+fe(this.childNodes).map(s=>{var i,o;const l=[];let a=s.nextSibling;for(;a&&a["s-sn"]===s["s-sn"];)(a.nodeType===3||a.nodeType===1)&&l.push((o=(i=a.textContent)==null?void 0:i.trim())!=null?o:""),a=a.nextSibling;return l.filter(c=>c!=="").join(" ")}).filter(s=>s!=="").join(" ")+" "},set(s){fe(this.childNodes).forEach(i=>{let o=i.nextSibling;for(;o&&o["s-sn"]===i["s-sn"];){const l=o;o=o.nextSibling,l.remove()}if(i["s-sn"]===""){const l=this.ownerDocument.createTextNode(s);l["s-sn"]="",v(i.parentElement,l,i.nextSibling)}else i.remove()})}}):Object.defineProperty(e,"textContent",{get(){var s;const i=z(this.childNodes,"",this.tagName);return((s=i?.nextSibling)==null?void 0:s.nodeType)===3?i.nextSibling.textContent:i?i.textContent:this.__textContent},set(s){var i;const o=z(this.childNodes,"",this.tagName);if(((i=o?.nextSibling)==null?void 0:i.nodeType)===3)o.nextSibling.textContent=s;else if(o)o.textContent=s;else{this.__textContent=s;const l=this["s-cr"];l&&v(this,l,this.firstChild)}}})},ot=(e,t)=>{class s extends Array{item(o){return this[o]}}if(t.$flags$&8){const i=e.__lookupGetter__("childNodes");Object.defineProperty(e,"children",{get(){return this.childNodes.map(o=>o.nodeType===1)}}),Object.defineProperty(e,"childElementCount",{get(){return e.children.length}}),Object.defineProperty(e,"childNodes",{get(){const o=i.call(this);if(!(p.$flags$&1)&&b(this).$flags$&2){const l=new s;for(let a=0;a<o.length;a++){const c=o[a]["s-nr"];c&&l.push(c)}return l}return s.from(o)}})}},fe=e=>{const t=[];for(const s of Array.from(e))s["s-sr"]&&t.push(s),t.push(...fe(s.childNodes));return t},lt=e=>e["s-sn"]||e.nodeType===1&&e.getAttribute("slot")||"",z=(e,t,s)=>{let i=0,o;for(;i<e.length;i++)if(o=e[i],o["s-sr"]&&o["s-sn"]===t&&o["s-hn"]===s||(o=z(o.childNodes,t,s),o))return o;return null},ue=(e,t)=>{const s=[e];for(;(e=e.nextSibling)&&e["s-sn"]===t;)s.push(e);return s},ks=(e,t)=>{const s={$flags$:t[0],$tagName$:t[1]};n.member&&(s.$members$=t[2]),n.hostListener&&(s.$listeners$=t[3]),n.watchCallback&&(s.$watchers$=e.$watchers$),n.reflect&&(s.$attrsToReflect$=[]),n.shadowDom&&!D&&s.$flags$&1&&(s.$flags$|=8),n.experimentalSlotFixes?n.scoped&&s.$flags$&2&&ts(e.prototype,s):(n.slotChildNodesFix&&ot(e.prototype,s),n.cloneNodeFix&&st(e.prototype),n.appendChildSlotFix&&nt(e.prototype),n.scopedSlotTextContentFix&&s.$flags$&2&&it(e.prototype));const i=e.prototype.connectedCallback,o=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){ft(this,s)},connectedCallback(){const l=b(this);he(this,l,s.$listeners$,!1),Zt(this),n.connectedCallback&&i&&i.call(this)},disconnectedCallback(){es(this),n.disconnectedCallback&&o&&o.call(this)},__attachShadow(){if(D){if(!this.shadowRoot)n.shadowDelegatesFocus?this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)}):this.attachShadow({mode:"open"});else if(this.shadowRoot.mode!=="open")throw new Error(`Unable to re-use existing shadow root for ${s.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`)}else this.shadowRoot=this}}),e.is=s.$tagName$,et(e,s,3)},he=(e,t,s,i)=>{n.hostListener&&s&&(n.hostListenerTargetParent&&(i?s=s.filter(([o])=>o&32):s=s.filter(([o])=>!(o&32))),s.map(([o,l,a])=>{const c=n.hostListenerTarget?cs(e,o):e,r=as(t,a),$=$s(o);p.ael(c,l,r,$),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>p.rel(c,l,r,$))}))},as=(e,t)=>s=>{var i;try{n.lazyLoad?e.$flags$&256?(i=e.$lazyInstance$)==null||i[t](s):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,s]):e.$hostElement$[t](s)}catch(o){_(o)}},cs=(e,t)=>n.hostListenerTargetDocument&&t&4?m:n.hostListenerTargetWindow&&t&8?E:n.hostListenerTargetBody&&t&16?m.body:n.hostListenerTargetParent&&t&32&&e.parentElement?e.parentElement:e,$s=e=>St?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0});export{_s as a,De as c,Ss as d,xs as f,Ls as i,ws as l,Tt as m,ys as n,bs as o,vs as p,At as r,Ts as s,ge as t,ks as u};
