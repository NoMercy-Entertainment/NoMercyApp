{"version":3,"file":"downloadWorker-CpeZaQyO.js","sources":["../node_modules/@videojs/vhs-utils/es/stream.js","../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/global/window.js","../node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js","../node_modules/m3u8-parser/dist/m3u8-parser.es.js","../src/lib/OfflineContentManager/downloadWorker.ts"],"sourcesContent":["/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n    // In Video.js we slice listener functions\n    // on trigger so that it does not mess up the order\n    // while we loop through.\n    //\n    // Here we slice on off so that the loop in trigger\n    // can continue using it's old reference to loop without\n    // messing up the order.\n\n    this.listeners[type] = this.listeners[type].slice(0);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\nexport { Stream as default };","function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","import window from 'global/window';\n\nvar atob = function atob(s) {\n  return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n};\n\nexport default function decodeB64ToUint8Array(b64Text) {\n  var decodedString = atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}","/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */\nimport Stream from '@videojs/vhs-utils/es/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array.js';\n\n/**\n * @file m3u8/line-stream.js\n */\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nclass LineStream extends Stream {\n  constructor() {\n    super();\n    this.buffer = '';\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  push(data) {\n    let nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  }\n\n}\n\nconst TAB = String.fromCharCode(0x09);\n\nconst parseByterange = function (byterangeString) {\n  // optionally match and capture 0+ digits before `@`\n  // optionally match and capture 0+ digits after `@`\n  const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n  const result = {};\n\n  if (match[1]) {\n    result.length = parseInt(match[1], 10);\n  }\n\n  if (match[2]) {\n    result.offset = parseInt(match[2], 10);\n  }\n\n  return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nconst attributeSeparator = function () {\n  const key = '[^=]*';\n  const value = '\"[^\"]*\"|[^,]*';\n  const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nconst parseAttributes = function (attributes) {\n  const result = {};\n\n  if (!attributes) {\n    return result;\n  } // split the string using attributes as the separator\n\n\n  const attrs = attributes.split(attributeSeparator());\n  let i = attrs.length;\n  let attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * Converts a string into a resolution object\n *\n * @param {string} resolution a string such as 3840x2160\n *\n * @return {Object} An object representing the resolution\n *\n */\n\n\nconst parseResolution = resolution => {\n  const split = resolution.split('x');\n  const result = {};\n\n  if (split[0]) {\n    result.width = parseInt(split[0], 10);\n  }\n\n  if (split[1]) {\n    result.height = parseInt(split[1], 10);\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nclass ParseStream extends Stream {\n  constructor() {\n    super();\n    this.customParsers = [];\n    this.tagMappers = [];\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  push(line) {\n    let match;\n    let event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    const newLines = this.tagMappers.reduce((acc, mapper) => {\n      const mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(newLine => {\n      for (let i = 0; i < this.customParsers.length; i++) {\n        if (this.customParsers[i].call(this, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        this.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n        return;\n      }\n\n      match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = _extends(parseByterange(match[1]), {\n          type: 'tag',\n          tagType: 'byterange'\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          const attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            event.byterange = parseByterange(attributes.BYTERANGE);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['FRAME-RATE']) {\n            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-START:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'skip'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n        }\n\n        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['INDEPENDENT', 'GAP'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n\n        if (event.attributes.hasOwnProperty('BYTERANGE')) {\n          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'server-control'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part-inf'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['PART-TARGET'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'preload-hint'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n            event.attributes.byterange = event.attributes.byterange || {};\n            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n            delete event.attributes[key];\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'rendition-report'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'daterange'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['ID', 'CLASS'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = String(event.attributes[key]);\n          }\n        });\n        ['START-DATE', 'END-DATE'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = new Date(event.attributes[key]);\n          }\n        });\n        ['DURATION', 'PLANNED-DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['END-ON-NEXT'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/i.test(event.attributes[key]);\n          }\n        });\n        ['SCTE35-CMD', ' SCTE35-OUT', 'SCTE35-IN'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = event.attributes[key].toString(16);\n          }\n        });\n        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n\n        for (const key in event.attributes) {\n          if (!clientAttributePattern.test(key)) {\n            continue;\n          }\n\n          const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n          const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n          event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'independent-segments'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-I-FRAMES-ONLY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'i-frames-only'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'content-steering'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'i-frame-playlist'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.URI) {\n          event.uri = event.attributes.URI;\n        }\n\n        if (event.attributes.BANDWIDTH) {\n          event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n        }\n\n        if (event.attributes.RESOLUTION) {\n          event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n        }\n\n        if (event.attributes['AVERAGE-BANDWIDTH']) {\n          event.attributes['AVERAGE-BANDWIDTH'] = parseInt(event.attributes['AVERAGE-BANDWIDTH'], 10);\n        }\n\n        if (event.attributes['FRAME-RATE']) {\n          event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DEFINE:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'define'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      } // unknown tag type\n\n\n      this.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser({\n    expression,\n    customType,\n    dataParser,\n    segment\n  }) {\n    if (typeof dataParser !== 'function') {\n      dataParser = line => line;\n    }\n\n    this.customParsers.push(line => {\n      const match = expression.exec(line);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType,\n          segment\n        });\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper({\n    expression,\n    map\n  }) {\n    const mapFn = line => {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  }\n\n}\n\nconst camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n\nconst camelCaseKeys = function (attributes) {\n  const result = {};\n  Object.keys(attributes).forEach(function (key) {\n    result[camelCase(key)] = attributes[key];\n  });\n  return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\n\n\nconst setHoldBack = function (manifest) {\n  const {\n    serverControl,\n    targetDuration,\n    partTargetDuration\n  } = manifest;\n\n  if (!serverControl) {\n    return;\n  }\n\n  const tag = '#EXT-X-SERVER-CONTROL';\n  const hb = 'holdBack';\n  const phb = 'partHoldBack';\n  const minTargetDuration = targetDuration && targetDuration * 3;\n  const minPartDuration = partTargetDuration && partTargetDuration * 2;\n\n  if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n    serverControl[hb] = minTargetDuration;\n    this.trigger('info', {\n      message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n    });\n  }\n\n  if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n    });\n    serverControl[hb] = minTargetDuration;\n  } // default no part hold back to part target duration * 3\n\n\n  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n    serverControl[phb] = partTargetDuration * 3;\n    this.trigger('info', {\n      message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n    });\n  } // if part hold back is too small default it to part target duration * 2\n\n\n  if (partTargetDuration && serverControl[phb] < minPartDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n    });\n    serverControl[phb] = minPartDuration;\n  }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @param {Object} [opts] Options for the constructor, needed for substitutions\n * @param {string} [opts.uri] URL to check for query params\n * @param {Object} [opts.mainDefinitions] Definitions on main playlist that can be imported\n * @extends Stream\n */\n\n\nclass Parser extends Stream {\n  constructor(opts = {}) {\n    super();\n    this.lineStream = new LineStream();\n    this.parseStream = new ParseStream();\n    this.lineStream.pipe(this.parseStream);\n    this.mainDefinitions = opts.mainDefinitions || {};\n    this.params = new URL(opts.uri, 'https://a.com').searchParams;\n    this.lastProgramDateTime = null;\n    /* eslint-disable consistent-this */\n\n    const self = this;\n    /* eslint-enable consistent-this */\n\n    const uris = [];\n    let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    let currentMap; // if specified, the active decryption key\n\n    let key;\n    let hasParts = false;\n\n    const noop = function () {};\n\n    const defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      dateRanges: [],\n      iFramePlaylists: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n    let lastPartByterangeEnd = 0;\n    const dateRangeTags = {};\n    this.on('end', () => {\n      // only add preloadSegment if we don't yet have a uri for it.\n      // and we actually have parts/preloadHints\n      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n        return;\n      }\n\n      if (!currentUri.map && currentMap) {\n        currentUri.map = currentMap;\n      }\n\n      if (!currentUri.key && key) {\n        currentUri.key = key;\n      }\n\n      if (!currentUri.timeline && typeof currentTimeline === 'number') {\n        currentUri.timeline = currentTimeline;\n      }\n\n      this.manifest.preloadSegment = currentUri;\n    }); // update the manifest with the m3u8 entry from the parse stream\n\n    this.parseStream.on('data', function (entry) {\n      let mediaGroup;\n      let rendition; // Replace variables in uris and attributes as defined in #EXT-X-DEFINE tags\n\n      if (self.manifest.definitions) {\n        for (const def in self.manifest.definitions) {\n          if (entry.uri) {\n            entry.uri = entry.uri.replace(`{$${def}}`, self.manifest.definitions[def]);\n          }\n\n          if (entry.attributes) {\n            for (const attr in entry.attributes) {\n              if (typeof entry.attributes[attr] === 'string') {\n                entry.attributes[attr] = entry.attributes[attr].replace(`{$${def}}`, self.manifest.definitions[def]);\n              }\n            }\n          }\n        }\n      }\n\n      ({\n        tag() {\n          // switch based on the tag type\n          (({\n            version() {\n              if (entry.version) {\n                this.manifest.version = entry.version;\n              }\n            },\n\n            'allow-cache'() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n\n            byterange() {\n              const byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n\n            endlist() {\n              this.manifest.endList = true;\n            },\n\n            inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.title) {\n                currentUri.title = entry.title;\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n\n            key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                  attributes: entry.attributes\n                };\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.microsoft.playready'] = {\n                  uri: entry.attributes.URI\n                };\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = this.manifest.contentProtection || {};\n                this.manifest.contentProtection['com.widevine.alpha'] = {\n                  attributes: {\n                    schemeIdUri: entry.attributes.KEYFORMAT,\n                    // remove '0x' from the key id string\n                    keyId: entry.attributes.KEYID.substring(2)\n                  },\n                  // decode the base64-encoded PSSH box\n                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                key.iv = entry.attributes.IV;\n              }\n            },\n\n            'media-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n\n            'discontinuity-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n\n            'playlist-type'() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n\n            map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n\n              if (key) {\n                currentMap.key = key;\n              }\n            },\n\n            'stream-inf'() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n\n            media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n\n            discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n\n            'program-date-time'() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n              const {\n                lastProgramDateTime\n              } = this;\n              this.lastProgramDateTime = new Date(entry.dateTimeString).getTime(); // We should extrapolate Program Date Time backward only during first program date time occurrence.\n              // Once we have at least one program date time point, we can always extrapolate it forward using lastProgramDateTime reference.\n\n              if (lastProgramDateTime === null) {\n                // Extrapolate Program Date Time backward\n                // Since it is first program date time occurrence we're assuming that\n                // all this.manifest.segments have no program date time info\n                this.manifest.segments.reduceRight((programDateTime, segment) => {\n                  segment.programDateTime = programDateTime - segment.duration * 1000;\n                  return segment.programDateTime;\n                }, this.lastProgramDateTime);\n              }\n            },\n\n            targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n              setHoldBack.call(this, this.manifest);\n            },\n\n            start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n\n            'cue-out'() {\n              currentUri.cueOut = entry.data;\n            },\n\n            'cue-out-cont'() {\n              currentUri.cueOutCont = entry.data;\n            },\n\n            'cue-in'() {\n              currentUri.cueIn = entry.data;\n            },\n\n            'skip'() {\n              this.manifest.skip = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n            },\n\n            'part'() {\n              hasParts = true; // parts are always specifed before a segment\n\n              const segmentIndex = this.manifest.segments.length;\n              const part = camelCaseKeys(entry.attributes);\n              currentUri.parts = currentUri.parts || [];\n              currentUri.parts.push(part);\n\n              if (part.byterange) {\n                if (!part.byterange.hasOwnProperty('offset')) {\n                  part.byterange.offset = lastPartByterangeEnd;\n                }\n\n                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n              }\n\n              const partIndex = currentUri.parts.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n\n              if (this.manifest.renditionReports) {\n                this.manifest.renditionReports.forEach((r, i) => {\n                  if (!r.hasOwnProperty('lastPart')) {\n                    this.trigger('warn', {\n                      message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                    });\n                  }\n                });\n              }\n            },\n\n            'server-control'() {\n              const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n\n              if (!attrs.hasOwnProperty('canBlockReload')) {\n                attrs.canBlockReload = false;\n                this.trigger('info', {\n                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                });\n              }\n\n              setHoldBack.call(this, this.manifest);\n\n              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                this.trigger('warn', {\n                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                });\n              }\n            },\n\n            'preload-hint'() {\n              // parts are always specifed before a segment\n              const segmentIndex = this.manifest.segments.length;\n              const hint = camelCaseKeys(entry.attributes);\n              const isPart = hint.type && hint.type === 'PART';\n              currentUri.preloadHints = currentUri.preloadHints || [];\n              currentUri.preloadHints.push(hint);\n\n              if (hint.byterange) {\n                if (!hint.byterange.hasOwnProperty('offset')) {\n                  // use last part byterange end or zero if not a part.\n                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n\n                  if (isPart) {\n                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                  }\n                }\n              }\n\n              const index = currentUri.preloadHints.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n\n              if (!hint.type) {\n                return;\n              } // search through all preload hints except for the current one for\n              // a duplicate type.\n\n\n              for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                const otherHint = currentUri.preloadHints[i];\n\n                if (!otherHint.type) {\n                  continue;\n                }\n\n                if (otherHint.type === hint.type) {\n                  this.trigger('warn', {\n                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                  });\n                }\n              }\n            },\n\n            'rendition-report'() {\n              const report = camelCaseKeys(entry.attributes);\n              this.manifest.renditionReports = this.manifest.renditionReports || [];\n              this.manifest.renditionReports.push(report);\n              const index = this.manifest.renditionReports.length - 1;\n              const required = ['LAST-MSN', 'URI'];\n\n              if (hasParts) {\n                required.push('LAST-PART');\n              }\n\n              this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n            },\n\n            'part-inf'() {\n              this.manifest.partInf = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n\n              if (this.manifest.partInf.partTarget) {\n                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n              }\n\n              setHoldBack.call(this, this.manifest);\n            },\n\n            'daterange'() {\n              this.manifest.dateRanges.push(camelCaseKeys(entry.attributes));\n              const index = this.manifest.dateRanges.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ['ID', 'START-DATE']);\n              const dateRange = this.manifest.dateRanges[index];\n\n              if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE'\n                });\n              }\n\n              if (dateRange.duration && dateRange.duration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE DURATION must not be negative'\n                });\n              }\n\n              if (dateRange.plannedDuration && dateRange.plannedDuration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE PLANNED-DURATION must not be negative'\n                });\n              }\n\n              const endOnNextYes = !!dateRange.endOnNext;\n\n              if (endOnNextYes && !dateRange.class) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute'\n                });\n              }\n\n              if (endOnNextYes && (dateRange.duration || dateRange.endDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes'\n                });\n              }\n\n              if (dateRange.duration && dateRange.endDate) {\n                const startDate = dateRange.startDate;\n                const newDateInSeconds = startDate.getTime() + dateRange.duration * 1000;\n                this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);\n              }\n\n              if (!dateRangeTags[dateRange.id]) {\n                dateRangeTags[dateRange.id] = dateRange;\n              } else {\n                for (const attribute in dateRangeTags[dateRange.id]) {\n                  if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {\n                    this.trigger('warn', {\n                      message: 'EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values'\n                    });\n                    break;\n                  }\n                } // if tags with the same ID do not have conflicting attributes, merge them\n\n\n                const dateRangeWithSameId = this.manifest.dateRanges.findIndex(dateRangeToFind => dateRangeToFind.id === dateRange.id);\n                this.manifest.dateRanges[dateRangeWithSameId] = _extends(this.manifest.dateRanges[dateRangeWithSameId], dateRange);\n                dateRangeTags[dateRange.id] = _extends(dateRangeTags[dateRange.id], dateRange); // after merging, delete the duplicate dateRange that was added last\n\n                this.manifest.dateRanges.pop();\n              }\n            },\n\n            'independent-segments'() {\n              this.manifest.independentSegments = true;\n            },\n\n            'i-frames-only'() {\n              this.manifest.iFramesOnly = true;\n              this.requiredCompatibilityversion(this.manifest.version, 4);\n            },\n\n            'content-steering'() {\n              this.manifest.contentSteering = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-CONTENT-STEERING', entry.attributes, ['SERVER-URI']);\n            },\n\n            /** @this {Parser} */\n            define() {\n              this.manifest.definitions = this.manifest.definitions || {};\n\n              const addDef = (n, v) => {\n                if (n in this.manifest.definitions) {\n                  // An EXT-X-DEFINE tag MUST NOT specify the same Variable Name as any other\n                  // EXT-X-DEFINE tag in the same Playlist.  Parsers that encounter duplicate\n                  // Variable Name declarations MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: Duplicate name ${n}`\n                  });\n                  return;\n                }\n\n                this.manifest.definitions[n] = v;\n              };\n\n              if ('QUERYPARAM' in entry.attributes) {\n                if ('NAME' in entry.attributes || 'IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n\n                const val = this.params.get(entry.attributes.QUERYPARAM);\n\n                if (!val) {\n                  // If the QUERYPARAM attribute value does not match any query parameter in\n                  // the URI or the matching parameter has no associated value, the parser\n                  // MUST fail to parse the Playlist.  If more than one parameter matches,\n                  // any of the associated values MAY be used.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No query param ${entry.attributes.QUERYPARAM}`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.QUERYPARAM, decodeURIComponent(val));\n                return;\n              }\n\n              if ('NAME' in entry.attributes) {\n                if ('IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n\n                if (!('VALUE' in entry.attributes) || typeof entry.attributes.VALUE !== 'string') {\n                  // This attribute is REQUIRED if the EXT-X-DEFINE tag has a NAME attribute.\n                  // The quoted-string MAY be empty.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value for ${entry.attributes.NAME}`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.NAME, entry.attributes.VALUE);\n                return;\n              }\n\n              if ('IMPORT' in entry.attributes) {\n                if (!this.mainDefinitions[entry.attributes.IMPORT]) {\n                  // Covers two conditions, as mainDefinitions will always be empty on main\n                  //\n                  // EXT-X-DEFINE tags containing the IMPORT attribute MUST NOT occur in\n                  // Multivariant Playlists; they are only allowed in Media Playlists.\n                  //\n                  // If the IMPORT attribute value does not match any Variable Name in the\n                  // Multivariant Playlist, or if the Media Playlist loaded from a\n                  // Multivariant Playlist, the parser MUST fail the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value ${entry.attributes.IMPORT} to import, or IMPORT used on main playlist`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.IMPORT, this.mainDefinitions[entry.attributes.IMPORT]);\n                return;\n              } // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a QUERYPARAM\n              // attribute, but only one of the three.  Otherwise, the client MUST fail to\n              // parse the Playlist.\n\n\n              this.trigger('error', {\n                message: 'EXT-X-DEFINE: No attribute'\n              });\n            },\n\n            'i-frame-playlist'() {\n              this.manifest.iFramePlaylists.push({\n                attributes: entry.attributes,\n                uri: entry.uri,\n                timeline: currentTimeline\n              });\n              this.warnOnMissingAttributes_('#EXT-X-I-FRAME-STREAM-INF', entry.attributes, ['BANDWIDTH', 'URI']);\n            }\n\n          })[entry.tagType] || noop).call(self);\n        },\n\n        uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (key) {\n            currentUri.key = key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // reset the last byterange end as it needs to be 0 between parts\n\n\n          lastPartByterangeEnd = 0; // Once we have at least one program date time we can always extrapolate it forward\n\n          if (this.lastProgramDateTime !== null) {\n            currentUri.programDateTime = this.lastProgramDateTime;\n            this.lastProgramDateTime += currentUri.duration * 1000;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n\n        comment() {// comments are not important for playback\n        },\n\n        custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n\n      })[entry.type].call(self);\n    });\n  }\n\n  requiredCompatibilityversion(currentVersion, targetVersion) {\n    if (currentVersion < targetVersion || !currentVersion) {\n      this.trigger('warn', {\n        message: `manifest must be at least version ${targetVersion}`\n      });\n    }\n  }\n\n  warnOnMissingAttributes_(identifier, attributes, required) {\n    const missing = [];\n    required.forEach(function (key) {\n      if (!attributes.hasOwnProperty(key)) {\n        missing.push(key);\n      }\n    });\n\n    if (missing.length) {\n      this.trigger('warn', {\n        message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n      });\n    }\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n\n  end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n\n    if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) {\n      this.trigger('warn', {\n        message: 'A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag'\n      });\n    }\n\n    this.lastProgramDateTime = null;\n    this.trigger('end');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  }\n\n}\n\nexport { LineStream, ParseStream, Parser };\n","import {Attributes, Manifest, Parser} from 'm3u8-parser';\n\ninterface WorkerTask {\n    mediaId: string;\n    mediaType: 'video' | 'music';\n    mediaPath: string;\n    subtitlePaths?: string[];\n    fontPaths?: string[];\n    previewPaths?: string[];\n}\n\ninterface ControlMessage {\n    type: 'pause' | 'resume' | 'pauseItem' | 'resumeItem';\n    itemId?: string;\n    pausedIds?: string[];  // Add this line\n}\n\ninterface WorkerMessage {\n    tasks: WorkerTask[];\n    baseUrl: string;\n    token: string;\n    controls?: ControlMessage;\n}\n\ninterface AssetProgress {\n    type: 'video' | 'audio' | 'subtitle' | 'preview' | 'font';\n    total: number;\n    completed: number;\n}\n\ninterface CustomManifestPlaylist extends Manifest {\n    attributes: Attributes;\n    uri: string;\n}\n\nlet isPaused = false;\nconst pausedItems = new Set<string>();\nlet cache: Cache | null = null;\nlet currentDownloads: { taskIndex: number; promise: Promise<any> }[] = [];\n\n// Simple fetch client that doesn't depend on localStorage\nasync function fetchWithAuth(path: string, baseUrl: string, token: string) {\n    const url = path.startsWith('http') ? path : `${baseUrl}${path}`;\n    const response = await fetch(url, {\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n    \n    if (!response.ok) {\n        throw new Error(`Failed to fetch ${path}: ${response.statusText}`);\n    }\n\n    return response;\n}\n\n// Update the checkPause helper to be more reliable\nasync function checkPause(taskId?: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n        if (isPaused || (taskId && pausedItems.has(taskId))) {\n            reject(new Error('paused'));\n        } else {\n            resolve();\n        }\n    });\n}\n\n// Add helper to update download status\nfunction updateItemStatus(taskId: string, status: string) {\n    self.postMessage({\n        type: 'status',\n        itemId: taskId,\n        status\n    });\n}\n\n// Track completed assets per item\nconst completedAssets = new Map<string, Set<string>>();\n\n// Track completed segments per item\nconst completedSegments = new Map<string, Set<string>>();\n\n// Function to generate unique cache keys\nfunction getCacheKey(mediaId: string, path: string): string {\n    return `${mediaId}:${path}`;\n}\n\n// Function to check cache and mark completed segments\nasync function checkCacheForCompletedSegments(\n    mediaId: string,\n    manifests: { path: string; segments: any[] }[],\n    type: AssetProgress['type'],\n    completedSegments: Set<string>\n): Promise<number> {\n    let completedCount = 0;\n\n    for (const manifest of manifests) {\n        const basePath = manifest.path.substring(0, manifest.path.lastIndexOf('/'));\n        \n        for (const segment of manifest.segments) {\n            const segmentUrl = segment.uri.startsWith('http')\n                ? segment.uri\n                : `${basePath}/${segment.uri}`;\n            \n            const segmentKey = getCacheKey(mediaId, segmentUrl);\n            const hasSegment = await cache?.match(segmentKey);\n            \n            if (hasSegment) {\n                completedSegments.add(segmentKey);\n                completedCount++;\n            }\n        }\n    }\n\n    return completedCount;\n}\n\nasync function downloadContent(task: WorkerTask, baseUrl: string, token: string) {\n    if (!cache) {\n        cache = await caches.open('offline-content-v1');\n    }\n\n    // Add pause check at start\n    await checkPause(task.mediaId);\n    if (isPaused || pausedItems.has(task.mediaId)) {\n        return false;\n    }\n\n    const assetProgress = new Map<string, AssetProgress>();\n\n    // Initialize or get completed assets for this item\n    if (!completedAssets.has(task.mediaId)) {\n        completedAssets.set(task.mediaId, new Set());\n    }\n    const itemCompletedAssets = completedAssets.get(task.mediaId)!;\n\n    // Initialize or get completed segments for this item\n    if (!completedSegments.has(task.mediaId)) {\n        completedSegments.set(task.mediaId, new Set());\n    }\n    const itemCompletedSegments = completedSegments.get(task.mediaId)!;\n\n    const updateAssetProgress = (type: AssetProgress['type'], total: number, initialCompleted: number = 0) => {\n        if (!assetProgress.has(type)) {\n            const progress = { type, total, completed: initialCompleted };\n            assetProgress.set(type, progress);\n            \n            // Send initial progress update with status 'downloading' instead of 'pending'\n            const overallProgress = calculateProgress();\n            self.postMessage({\n                type: 'progress',\n                progress: overallProgress.progress,\n                currentItem: overallProgress.completedItems,\n                totalItems: overallProgress.totalItems,\n                itemProgress: Math.round((initialCompleted / total) * 100),\n                assetType: type,\n                assetProgress: Math.round((initialCompleted / total) * 100),\n                itemId: task.mediaId,\n                status: 'downloading' // Always start as downloading\n            });\n\n            // Only mark as completed if truly done\n            if (initialCompleted === total && type !== 'video' && type !== 'audio') {\n                itemCompletedAssets.add(type);\n            }\n        }\n    };\n\n    const incrementAssetProgress = (type: AssetProgress['type']) => {\n        const progress = assetProgress.get(type);\n        if (progress) {\n            progress.completed++;\n            const percentage = Math.round((progress.completed / progress.total) * 100);\n            \n            // Only mark asset as complete if it's truly finished AND not a segmented asset\n            if (percentage === 100 && type !== 'video' && type !== 'audio') {\n                itemCompletedAssets.add(type);\n            }\n            \n            // Don't mark video/audio as completed until all segments are processed\n            const isSegmentedAsset = type === 'video' || type === 'audio';\n            const isFullyComplete = percentage === 100 && !isSegmentedAsset;\n            \n            // Calculate overall progress\n            const overallProgress = calculateProgress();\n            \n            self.postMessage({\n                type: 'progress',\n                progress: overallProgress.progress,\n                currentItem: overallProgress.completedItems,\n                totalItems: overallProgress.totalItems,\n                itemProgress: percentage,\n                assetType: type,\n                assetProgress: percentage,\n                itemId: task.mediaId,\n                status: isFullyComplete ? 'completed' : 'downloading'\n            });\n\n            // Only update completion status after all segments are actually downloaded\n            if (percentage === 100 && !isSegmentedAsset) {\n                // ...rest of completion logic...\n            }\n        }\n    };\n\n    try {\n        // Add pause check before each major operation\n        await checkPause(task.mediaId);\n\n        if (task.mediaPath.includes('.m3u8')) {\n            const manifestResponse = await fetchWithAuth(task.mediaPath, baseUrl, token);\n            const manifest = await manifestResponse.text();\n\n            const parser = new Parser();\n            parser.push(manifest);\n            parser.end();\n\n            const parsedManifest = parser.manifest;\n            const basePath = task.mediaPath.substring(0, task.mediaPath.lastIndexOf('/'));\n\n            // First handle video playlists and count total segments\n            let totalVideoSegments = 0;\n            const videoManifests: { path: string; segments: any[] }[] = [];\n\n            // If we have playlists, this is a master manifest\n            if (parsedManifest.playlists?.length) {\n                for (const playlist of parsedManifest.playlists as unknown as CustomManifestPlaylist[]) {\n                    const playlistPath = playlist.uri.startsWith('http')\n                        ? playlist.uri\n                        : `${basePath}/${playlist.uri}`;\n\n                    const playlistResponse = await fetchWithAuth(playlistPath, baseUrl, token);\n                    const playlistManifest = await playlistResponse.text();\n\n                    const playlistParser = new Parser();\n                    playlistParser.push(playlistManifest);\n                    playlistParser.end();\n\n                    if (playlistParser.manifest.segments?.length) {\n                        totalVideoSegments += playlistParser.manifest.segments.length;\n                        videoManifests.push({\n                            path: playlistPath,\n                            segments: playlistParser.manifest.segments\n                        });\n                    }\n                }\n            } \n            // If we have segments directly, this is a variant manifest\n            else if (parsedManifest.segments?.length) {\n                totalVideoSegments = parsedManifest.segments.length;\n                videoManifests.push({\n                    path: task.mediaPath,\n                    segments: parsedManifest.segments\n                });\n            }\n\n            // Process video segments if we have any\n            if (totalVideoSegments > 0) {\n                // Check cache for already completed video segments\n                const completedVideoSegments = await checkCacheForCompletedSegments(\n                    task.mediaId, \n                    videoManifests, \n                    'video',\n                    itemCompletedSegments\n                );\n                updateAssetProgress('video', totalVideoSegments, completedVideoSegments);\n\n                // Only process segments that aren't already completed\n                for (const manifest of videoManifests) {\n                    const videoBasePath = manifest.path.substring(0, manifest.path.lastIndexOf('/'));\n\n                    for (const segment of manifest.segments) {\n                        await checkPause(task.mediaId);\n                        const segmentUrl = segment.uri.startsWith('http')\n                            ? segment.uri\n                            : `${videoBasePath}/${segment.uri}`;\n\n                        // Skip if this segment is already downloaded\n                        const segmentKey = getCacheKey(task.mediaId, segmentUrl);\n                        \n                        if (itemCompletedSegments.has(segmentKey)) {\n                            // Skip this segment entirely as it's already counted in completedVideoSegments\n                            continue;\n                        }\n                        \n                        const hasSegment = await cache.match(segmentKey);\n                        if (hasSegment) {\n                            itemCompletedSegments.add(segmentKey);\n                            // Skip this segment entirely as it's already counted in completedVideoSegments\n                            continue;\n                        }\n                        \n                        await checkPause(task.mediaId);\n                        const response = await fetchWithAuth(segmentUrl, baseUrl, token).then(r => r.blob());\n                        const responseClone = new Response(response.slice(0));\n                        await cache.put(segmentKey, responseClone);\n                        itemCompletedSegments.add(segmentKey);\n                        incrementAssetProgress('video');\n                    }\n                }\n            }\n\n            // Handle audio segments\n            if (parsedManifest.mediaGroups?.AUDIO) {\n                // First count total audio segments across all languages\n                let totalAudioSegments = 0;\n                const audioManifests: { path: string; segments: any[] }[] = [];\n                \n                // First pass: gather all audio manifests and count total segments\n                for (const group of Object.values(parsedManifest.mediaGroups.AUDIO)) {\n                    for (const audio of Object.values(group) as unknown as CustomManifestPlaylist[]) {\n                        if (!audio.uri) continue;\n\n                        const audioManifestPath = audio.uri.startsWith('http')\n                            ? audio.uri\n                            : `${basePath}/${audio.uri}`;\n\n                        const audioResponse = await fetchWithAuth(audioManifestPath, baseUrl, token);\n                        const audioManifest = await audioResponse.text();\n\n                        const audioParser = new Parser();\n                        audioParser.push(audioManifest);\n                        audioParser.end();\n\n                        if (audioParser.manifest.segments?.length) {\n                            totalAudioSegments += audioParser.manifest.segments.length;\n                            audioManifests.push({\n                                path: audioManifestPath,\n                                segments: audioParser.manifest.segments\n                            });\n                        }\n                    }\n                }\n\n                // Initialize progress with total segments from all audio tracks\n                if (totalAudioSegments > 0) {\n                    // Check cache for already completed audio segments\n                    const completedAudioSegments = await checkCacheForCompletedSegments(\n                        task.mediaId, \n                        audioManifests, \n                        'audio',\n                        itemCompletedSegments\n                    );\n                    updateAssetProgress('audio', totalAudioSegments, completedAudioSegments);\n\n                    // Second pass: download all segments that aren't already completed\n                    for (const manifest of audioManifests) {\n                        const audioBasePath = manifest.path.substring(0, manifest.path.lastIndexOf('/'));\n\n                        for (const segment of manifest.segments) {\n                            await checkPause(task.mediaId);\n                            const segmentUrl = segment.uri.startsWith('http')\n                                ? segment.uri\n                                : `${audioBasePath}/${segment.uri}`;\n\n                            // Skip if this segment is already downloaded\n                            const segmentKey = getCacheKey(task.mediaId, segmentUrl);\n                            \n                            if (itemCompletedSegments.has(segmentKey)) {\n                                // Skip this segment entirely as it's already counted in completedAudioSegments\n                                continue;\n                            }\n                            \n                            const hasSegment = await cache.match(segmentKey);\n                            if (hasSegment) {\n                                itemCompletedSegments.add(segmentKey);\n                                // Skip this segment entirely as it's already counted in completedAudioSegments\n                                continue;\n                            }\n                            \n                            await checkPause(task.mediaId);\n                            const response = await fetchWithAuth(segmentUrl, baseUrl, token).then(r => r.blob());\n                            const responseClone = new Response(response.slice(0));\n                            await cache.put(segmentKey, responseClone);\n                            itemCompletedSegments.add(segmentKey);\n                            incrementAssetProgress('audio');\n                        }\n                    }\n                }\n            }\n        } else {\n            // Check if we already have the video file\n            const videoKey = getCacheKey(task.mediaId, task.mediaPath);\n            const hasVideo = await cache.match(videoKey);\n            \n            // Only download video if not already cached\n            if (!hasVideo) {\n                // Download video file\n                const videoUrl = `${baseUrl}${task.mediaPath}`;\n                const response = await fetch(videoUrl, {\n                    headers: {\n                        'Authorization': `Bearer ${token}`\n                    }\n                });\n\n                if (!response.ok) {\n                    throw new Error(`Failed to download video: ${response.statusText}`);\n                }\n\n                await cache.put(videoKey, response.clone());\n                \n                // Mark video as completed\n                itemCompletedAssets.add('video');\n                \n                self.postMessage({\n                    type: 'progress',\n                    progress: calculateProgress().progress,\n                    currentItem: calculateProgress().completedItems,\n                    totalItems: calculateProgress().totalItems,\n                    itemProgress: 100,\n                    assetType: 'video',\n                    assetProgress: 100,\n                    itemId: task.mediaId,\n                    status: 'downloading'\n                });\n            } else {\n                // If video was already cached, mark it as completed\n                itemCompletedAssets.add('video');\n                self.postMessage({\n                    type: 'progress',\n                    progress: calculateProgress().progress,\n                    currentItem: calculateProgress().completedItems,\n                    totalItems: calculateProgress().totalItems,\n                    itemProgress: 100,\n                    assetType: 'video',\n                    assetProgress: 100,\n                    itemId: task.mediaId,\n                    status: 'downloading'\n                });\n            }\n        }\n\n        // Initialize and track other assets\n        if (task.subtitlePaths?.length) {\n            updateAssetProgress('subtitle', task.subtitlePaths.length);\n            for (const path of task.subtitlePaths) {\n                // Skip if this subtitle is already downloaded\n                const subtitleKey = getCacheKey(task.mediaId, path);\n                const hasSubtitle = await cache.match(subtitleKey);\n                \n                if (!hasSubtitle) {\n                    await checkPause(task.mediaId);\n                    const response = await fetchWithAuth(path, baseUrl, token);\n                    await cache.put(subtitleKey, response.clone());\n                }\n                \n                incrementAssetProgress('subtitle');\n            }\n        }\n\n        if (task.previewPaths?.length) {\n            updateAssetProgress('preview', task.previewPaths.length);\n            for (const path of task.previewPaths) {\n                // Skip if this preview is already downloaded\n                const previewKey = getCacheKey(task.mediaId, path);\n                const hasPreview = await cache.match(previewKey);\n                \n                if (!hasPreview) {\n                    await checkPause(task.mediaId);\n                    const response = await fetchWithAuth(path, baseUrl, token);\n                    await cache.put(previewKey, response.clone());\n                }\n                \n                incrementAssetProgress('preview');\n            }\n        }\n\n        if (task.fontPaths?.length) {\n            let totalFontFiles = 0;\n            const fontPaths = [];\n\n            // Fetch fonts.json and count total font files\n            for (const path of task.fontPaths) {\n                const response = await fetchWithAuth(path, baseUrl, token);\n                const fonts = await response.json();\n                totalFontFiles += fonts.length;\n                fontPaths.push({ path, fonts });\n            }\n\n            updateAssetProgress('font', totalFontFiles);\n\n            for (const { path, fonts } of fontPaths) {\n                const fontKey = getCacheKey(task.mediaId, path);\n                const hasFont = await cache.match(fontKey);\n                \n                if (!hasFont) {\n                    await checkPause(task.mediaId);\n                    const basePath = path.substring(0, path.lastIndexOf('/') + 1);\n                    \n                    for (const font of fonts) {\n                        await checkPause(task.mediaId);\n                        const fontUrl = `${basePath}fonts/${font.file}`;\n                        const fontFileKey = getCacheKey(task.mediaId, fontUrl);\n                        \n                        // Check if this specific font file is already cached\n                        const hasFontFile = await cache.match(fontFileKey);\n                        if (!hasFontFile) {\n                            const fontResponse = await fetchWithAuth(fontUrl, baseUrl, token);\n                            await cache.put(fontFileKey, fontResponse.clone());\n                            incrementAssetProgress('font'); // Increment progress for each font file\n                        } else {\n                            incrementAssetProgress('font'); // Increment progress if font is already cached\n                        }\n                    }\n                    \n                    // Cache the manifest after processing all font files\n                    await cache.put(fontKey, new Response(JSON.stringify(fonts)));\n                } else {\n                    // Increment progress for each font file in the cached manifest\n                    fonts.forEach(() => incrementAssetProgress('font'));\n                }\n            }\n        }\n    } catch (error: any) {\n        if (error?.message === 'paused') {\n            return false;\n        }\n        throw error;\n    }\n}\n\n// Keep track of initial tasks\nlet originalTasks: WorkerTask[] = [];\nlet baseUrl: string = '';\nlet token: string = '';\n\n// Update the processQueue function to handle pauses more reliably\nasync function processQueue(tasks: WorkerTask[], baseUrl: string, token: string) {\n    let index = 0;\n    \n    while (index < tasks.length) {\n        const task = tasks[index];\n        \n        // Set current task to downloading and next tasks to waiting\n        updateItemStatus(task.mediaId, 'downloading');\n        tasks.slice(index + 1).forEach(nextTask => {\n            if (!completedItems.get(nextTask.mediaId) && !pausedItems.has(nextTask.mediaId)) {\n                updateItemStatus(nextTask.mediaId, 'waiting');\n            }\n        });\n\n        try {\n            // Check pause state before starting each task\n            if (isPaused) {\n                updateItemStatus(task.mediaId, 'paused');\n                return; // Exit the queue entirely when globally paused\n            }\n            \n            if (pausedItems.has(task.mediaId)) {\n                updateItemStatus(task.mediaId, 'paused');\n                index++;\n                continue; // Skip this task but continue with others\n            }\n\n            // Track current download\n            const taskIndex = originalTasks.indexOf(task);\n            currentDownloads = [{\n                taskIndex,\n                promise: downloadContent(task, baseUrl, token)\n            }];\n\n            updateItemStatus(task.mediaId, 'downloading');\n            const result = await currentDownloads[0].promise;\n            \n            if (result === false) {\n                // Task was paused\n                updateItemStatus(task.mediaId, 'paused');\n                if (isPaused) return; // Exit queue if globally paused\n                index++; // Move to next task if individually paused\n            } else {\n                // Task completed successfully\n                updateItemStatus(task.mediaId, 'completed');\n                index++;\n            }\n        } catch (error: any) {\n            if (error?.message === 'paused') {\n                updateItemStatus(task.mediaId, 'paused');\n                if (isPaused) return; // Exit queue if globally paused\n                index++; // Move to next task if individually paused\n            } else {\n                updateItemStatus(task.mediaId, 'error');\n                throw error;\n            }\n        }\n    }\n\n    // Only send complete if there are no paused items\n    const pausedCount = tasks.filter(t => pausedItems.has(t.mediaId)).length;\n    if (pausedCount === 0) {\n        const progress = calculateProgress();\n        self.postMessage({ \n            type: 'complete',\n            progress: progress.progress,\n            currentItem: progress.completedItems,\n            totalItems: progress.totalItems\n        });\n    }\n}\n\n// Add a set to track completed items and their completion status\nconst completedItems = new Map<string, boolean>(); // mediaId -> isFullyCompleted\n\n// Add a function to calculate overall progress\nfunction calculateProgress() {\n    // Count fully completed items\n    const completedCount = Array.from(completedItems.values()).filter(isComplete => isComplete).length;\n    \n    // Calculate progress including partially completed items\n    let totalProgress = 0;\n    originalTasks.forEach((task) => {\n        if (completedItems.get(task.mediaId)) {\n            // If item is fully completed, add 100%\n            totalProgress += 100;\n        } else if (completedAssets.has(task.mediaId)) {\n            // Calculate total required assets for this task\n            const requiredAssets = new Set(['video']);\n            if (task.subtitlePaths?.length) requiredAssets.add('subtitle');\n            if (task.fontPaths?.length) requiredAssets.add('font');\n            if (task.previewPaths?.length) requiredAssets.add('preview');\n            \n            // Calculate progress based on completed required assets\n            const assets = completedAssets.get(task.mediaId)!;\n            const completedRequired = Array.from(requiredAssets).filter(type => assets.has(type)).length;\n            totalProgress += (completedRequired / requiredAssets.size) * 100;\n        }\n    });\n    \n    return {\n        progress: Math.round(totalProgress / originalTasks.length),\n        completedItems: completedCount,\n        totalItems: originalTasks.length\n    };\n}\n\nself.onmessage = async (e: MessageEvent<WorkerMessage>) => {\n    const { tasks, controls } = e.data;\n\n    // Store initial config\n    if (tasks) {\n        originalTasks = tasks;\n        baseUrl = e.data.baseUrl;\n        token = e.data.token;\n        // Reset tracking sets\n        completedItems.clear();\n        pausedItems.clear();\n    }\n\n    // Update the message handler to be more robust with pause/resume\n    if (controls) {\n        const { type, itemId } = controls;\n        \n        switch (type) {\n            case 'pause':\n                isPaused = true;\n                // Only pause non-completed items\n                originalTasks.forEach(task => {\n                    const isCompleted = completedItems.get(task.mediaId);\n                    if (!isCompleted) {\n                        pausedItems.add(task.mediaId);\n                        self.postMessage({\n                            type: 'status',\n                            itemId: task.mediaId,\n                            status: 'paused'\n                        });\n                    }\n                });\n                break;\n                \n            case 'resume':\n                isPaused = false;\n                pausedItems.clear();\n                \n                // Only resume tasks that were explicitly paused\n                // eslint-disable-next-line no-case-declarations\n                const pausedIds = controls.pausedIds || [];\n                // eslint-disable-next-line no-case-declarations\n                const remainingTasks = originalTasks.filter(t =>\n                    !completedItems.get(t.mediaId) && \n                    pausedIds.includes(t.mediaId)\n                );\n                \n                if (remainingTasks.length) {\n                    remainingTasks.forEach(task => {\n                        updateItemStatus(task.mediaId, 'pending');\n                    });\n                    try {\n                        await processQueue(remainingTasks, baseUrl, token);\n                    } catch (error) {\n                        console.error('Failed to resume queue:', error);\n                    }\n                }\n                break;\n\n            case 'pauseItem':\n                if (itemId) {\n                    pausedItems.add(itemId);\n                    updateItemStatus(itemId, 'paused');\n                }\n                break;\n                \n            case 'resumeItem':\n                if (itemId) {\n                    pausedItems.delete(itemId);\n                    updateItemStatus(itemId, 'pending');\n                    \n                    const task = originalTasks.find(t => t.mediaId === itemId);\n                    if (task && !completedItems.get(task.mediaId)) {\n                        try {\n                            const tempPaused = isPaused;\n                            isPaused = false;\n                            await processQueue([task], baseUrl, token);\n                            isPaused = tempPaused;\n                        } catch (error) {\n                            console.error('Failed to resume item:', error);\n                            updateItemStatus(itemId, 'error');\n                        }\n                    }\n                }\n                break;\n        }\n        return;\n    }\n\n    // Initial start of queue processing - filter out any completed items\n    const nonCompletedTasks = tasks.filter(t => !completedItems.get(t.mediaId));\n    await processQueue(nonCompletedTasks, baseUrl, token);\n};\n"],"names":["Stream","_proto","type","listener","index","callbacks","length","i","args","_length","_i","destination","data","_extends","e","t","r","win","global","window_1","atob","s","window","decodeB64ToUint8Array","b64Text","decodedString","array","LineStream","nextNewline","TAB","parseByterange","byterangeString","match","result","attributeSeparator","keyvalue","parseAttributes","attributes","attrs","attr","parseResolution","resolution","split","ParseStream","line","event","acc","mapper","mappedLine","newLine","key","subkey","clientAttributePattern","isHexaDecimal","isDecimalFloating","expression","customType","dataParser","segment","map","mapFn","camelCase","str","camelCaseKeys","setHoldBack","manifest","serverControl","targetDuration","partTargetDuration","tag","hb","phb","minTargetDuration","minPartDuration","Parser","opts","self","uris","currentUri","currentMap","hasParts","noop","defaultMediaGroups","widevineUuid","currentTimeline","lastByterangeEnd","lastPartByterangeEnd","dateRangeTags","entry","mediaGroup","rendition","def","byterange","mediaGroupType","lastProgramDateTime","programDateTime","segmentIndex","part","partIndex","hint","isPart","otherHint","report","required","dateRange","endOnNextYes","newDateInSeconds","attribute","dateRangeWithSameId","dateRangeToFind","addDef","n","v","val","currentVersion","targetVersion","identifier","missing","chunk","options","isPaused","pausedItems","cache","currentDownloads","fetchWithAuth","path","baseUrl","token","url","response","checkPause","taskId","resolve","reject","updateItemStatus","status","completedAssets","completedSegments","getCacheKey","mediaId","checkCacheForCompletedSegments","manifests","completedCount","basePath","segmentUrl","segmentKey","downloadContent","task","assetProgress","itemCompletedAssets","itemCompletedSegments","updateAssetProgress","total","initialCompleted","progress","overallProgress","calculateProgress","incrementAssetProgress","percentage","isFullyComplete","parser","parsedManifest","totalVideoSegments","videoManifests","_a","playlist","playlistPath","playlistManifest","playlistParser","_b","_c","completedVideoSegments","videoBasePath","responseClone","_d","totalAudioSegments","audioManifests","group","audio","audioManifestPath","audioManifest","audioParser","_e","completedAudioSegments","audioBasePath","videoKey","videoUrl","_f","subtitleKey","_g","previewKey","_h","totalFontFiles","fontPaths","fonts","fontKey","font","fontUrl","fontFileKey","fontResponse","error","originalTasks","processQueue","tasks","nextTask","completedItems","isComplete","totalProgress","requiredAssets","assets","completedRequired","controls","itemId","pausedIds","remainingTasks","tempPaused","nonCompletedTasks"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}