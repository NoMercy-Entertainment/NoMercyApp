# NoMercy.App Performance Optimization Progress

## Completed Tasks

### Phase 1.1: Configure Manual Chunks (vite.config.ts)
- Status: DONE (prior to this session)
- Changed manualChunks from object syntax to function syntax for rolldown-vite compatibility

### Phase 1.2: Fix Layout Imports (src/router/routes.ts)
- Status: DONE
- Date: 2026-02-05
- Changed layout imports from immediate execution to lazy-loaded functions:
  - `const MobileBaseLayout = import(...)` → `const MobileBaseLayout = () => import(...)`
  - `const DesktopBaseLayout = import(...)` → `const DesktopBaseLayout = () => import(...)`
- This prevents both layouts from loading at module initialization; only the needed layout loads when used

### Phase 1.3: Remove Swiper Duplication
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Removed web component bundle import and registration from src/setupApp.ts:
     - Removed `import { register as registerSwiperElements } from 'swiper/element/bundle';`
     - Removed `registerSwiperElements();` call
  2. Removed duplicate web component registration from src/components/Carousel/Carousel.vue:
     - Removed `import { register } from 'swiper/element/bundle';`
     - Removed `register();` call
- The app now only uses Vue Swiper components (Swiper, SwiperSlide from 'swiper/vue')
- This eliminates ~100KB of duplicate Swiper code (web component bundle)

### Phase 1.4: Add Preconnect Hints (index.html)
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Removed placeholder dns-prefetch for `//api.example.com`
  2. Removed `x-dns-prefetch-control: off` meta tag
  3. Added preconnect hints for external domains:
     - `https://media.themoviedb.org` (TMDB images)
     - `https://app.nomercy.tv` (app server)
     - `https://auth-dev.nomercy.tv` (Keycloak auth)
     - `https://fonts.bunny.net` (Google Fonts alternative)
  4. Added dns-prefetch for `https://cdn.nomercy.tv`
- Font preloads already existed in the file, kept as is

### Phase 2.1: Convert NM Components to Local Component Map with Lazy Loading
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Created src/components/nmComponentMap.ts:
     - Single shared export with all 15 NM components as defineAsyncComponent lazy imports
     - Used by all components that render dynamic NM components
  2. Updated src/setupApp.ts:
     - Removed all NM component imports and global registrations
     - Removed unused supportsCarousel variable and isMobile import
  3. Updated components to use shared nmComponentMap:
     - src/components/NMComponent.vue
     - src/components/NMCarousel.vue
     - src/components/NMCarousel2.vue
     - src/components/NMContainer.vue
     - src/components/NMList.vue
     - src/components/NMGrid.vue
- Benefits:
  - Single source of truth for NM component map (DRY principle)
  - NM components now load only when API requests them
  - Reduces initial bundle size (components split into separate chunks)
  - Easy to add new NM components - just update nmComponentMap.ts

### Phase 2.1b: Add Loading Skeletons for Lazy-Loaded Components
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Created src/components/Loading/NMCardSkeleton.vue:
     - Animated pulse placeholder with correct aspect ratio (poster/backdrop)
     - Matches card dimensions to prevent layout shift
  2. Updated src/components/nmComponentMap.ts:
     - Card components now use loadingComponent option with NMCardSkeleton
     - Applied to: NMCard, NMGenreCard, NMHomeCard, NMSeasonCard, NMMusicCard,
       NMMusicHomeCard, NMTopResultCard
- Benefits:
  - Prevents CLS (Cumulative Layout Shift) while async components load
  - Smooth loading experience with animated placeholders

### Phase 2.2: Use defineAsyncComponent for Heavy Components
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Created src/components/Loading/MusicPlayerSkeleton.vue:
     - Skeleton placeholder matching the desktop music player layout
     - Shows animated pulse placeholders for cover, controls, and volume
  2. Created src/components/async.ts:
     - AsyncMusicPlayerDesktop: lazy-loaded with MusicPlayerSkeleton
     - AsyncMusicPlayerFull: lazy-loaded mobile full player
     - AsyncMusicPlayerMini: lazy-loaded mobile mini player
  3. Updated src/Layout/Desktop/BaseLayout.vue:
     - Changed MusicPlayerDesktop import to AsyncMusicPlayerDesktop
  4. Updated src/Layout/Mobile/BaseLayout.vue:
     - Changed FullPlayer and MiniPlayer imports to async versions
- Notes:
  - VideoPlayer: Already an external library (@nomercy-entertainment/nomercy-video-player), not a Vue component
  - Dashboard: Already uses defineAsyncComponent with route-based lazy loading
  - Focus was on MusicPlayer components which were eagerly loaded in layouts

### Phase 2.3: Implement Component-Level Code Splitting (Swiper local imports)
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Removed global Swiper registration from src/setupApp.ts:
     - Removed `import { Swiper } from 'swiper'` and `import { SwiperSlide } from 'swiper/vue'`
     - Removed `app.component('Swiper', Swiper)` and `app.component('SwiperSlide', SwiperSlide)`
  2. Moved Swiper CSS from global to local imports:
     - Removed `import 'swiper/css'` and `import 'swiper/element/css/keyboard'` from src/main.ts
     - Added `import 'swiper/css'` locally in 4 components that use Swiper:
       - src/components/Carousel/Carousel.vue
       - src/components/NMCarousel.vue
       - src/components/MusicPlayer/mobile/FullPlayer.vue
       - src/views/Base/Person/Mobile.vue
  3. Removed unused `swiper/element/css/keyboard` import (keyboard: false in swiper config)
- All components already had local Swiper JS imports; only global registration and CSS were remaining
- Benefits:
  - Swiper JS and CSS are fully code-split from the main bundle
  - Swiper code only loads when a carousel or swiper-using component is rendered
  - Removed unnecessary keyboard CSS import

### Phase 3.2: Responsive Image Loading (TMDBImage.vue)
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Added device pixel ratio detection (reads window.devicePixelRatio once at module level)
  2. Created `optimizedSize` computed that uses 2x multiplier only for high-DPI displays (>1.5 DPR),
     1x multiplier for standard displays (previously always used 2x)
  3. Added `&format=webp` to server image URL to request WebP format from the image proxy
  4. Updated `<source>` element with `type="image/webp"` for proper format negotiation
  5. Cleaned up commented-out source elements
  6. Preserved color palette gradient placeholder (Phase 3.1 - already correct, no changes needed)
  7. TMDB fallback URL kept as-is for browsers that don't support WebP
- Benefits:
  - 1x displays no longer download 2x resolution images (saves ~75% bandwidth for those users)
  - WebP format delivers ~25-35% smaller images vs JPEG/PNG
  - `<picture>` element with `<source type="image/webp">` provides automatic format fallback
  - Color palette gradient placeholders preserved as-is (PRD 3.1)

### Phase 4.1: Optimize TanStack Query Configuration
- Status: DONE
- Date: 2026-02-05
- File: src/config/tanstack-query.ts
- Changes made:
  1. Changed `retry: false` → `retry: 1` (one retry attempt for resilience)
  2. Added `retryDelay` with exponential backoff: `Math.min(1000 * 2 ** attemptIndex, 30000)`
  3. Changed `staleTime` from 1 hour (`1000 * 60 * 60`) to 5 minutes (`1000 * 60 * 5`)
  4. Added `gcTime: 1000 * 60 * 30` (garbage collect unused cache after 30 minutes)
  5. Preserved `experimental_prefetchInRender: true` (existing optimization)
- Benefits:
  - Failed requests get one retry with backoff instead of immediately failing
  - Stale data refetched sooner (5min vs 1hr) for fresher content
  - Unused query cache garbage-collected after 30min to reduce memory usage

### Phase 4.2: Replace structuredClone with Targeted Updates
- Status: DONE
- Date: 2026-02-05
- File: src/lib/routerHelper.ts
- Changes made:
  1. Replaced `structuredClone(toRaw(d))` on every item with targeted shallow copies:
     - Build a Set of `replace_id` values from the mutations
     - Only shallow-clone (`{ ...d }`) items whose `id` is in the mutation set
     - Unchanged items keep their original reference (no copy at all)
  2. Removed unused `toRaw` import from vue
- Benefits:
  - Eliminates expensive deep cloning of potentially large data arrays
  - Only items about to be replaced get a shallow copy (which is immediately overwritten anyway)
  - Reduces GC pressure and improves mutation performance

### Phase 4.3: Implement Request Deduplication
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Added `deduplicatedRequest` utility to src/lib/clients/serverClient.ts:
     - Maintains a Map of in-flight requests keyed by a string identifier
     - If a request with the same key is already pending, returns the existing promise
     - Cleans up the Map entry when the request completes (success or failure)
  2. Integrated into router middleware files that make direct serverClient calls:
     - src/router/middleware/getServerSetup.ts - wraps `setup/server-info` request
     - src/router/middleware/getLibraries.ts - wraps `setup/libraries` request
     - src/router/middleware/getServerPermissions.ts - wraps `setup/permissions` request
- Benefits:
  - Prevents duplicate in-flight requests during rapid navigation
  - Middleware functions that get called multiple times before completion share the same request
  - TanStack Query already handles deduplication for useServerClient hook; this covers direct serverClient usage
  - Zero overhead when no duplicate requests occur (just a Map lookup)

### Phase 5.1: Optimize ScrollContainer
- Status: DONE
- Date: 2026-02-05
- File: src/Layout/Desktop/components/ScrollContainer.vue
- Changes made:
  1. Replaced `router.afterEach(enable)` with section-aware navigation handler
  2. Tracks the current top-level route section (first path segment)
  3. When navigating within the same section: only scrolls to top (cheap operation)
  4. When navigating to a different section: calls full `enable()` to reinitialize scrollbar
- Benefits:
  - Eliminates unnecessary teardown/re-initialization of scrollbar listeners on every navigation
  - Same-section navigations (e.g. /movies/123 → /movies/456) just scroll to top
  - Cross-section navigations (e.g. /movies → /music) still get full scrollbar reset
  - Reduces ResizeObserver churn and event listener rebinding overhead

### Phase 5.2: Implement Virtual Scrolling for Long Lists
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Updated src/lib/swiper-config.ts:
     - Changed `virtual: false` to `virtual: { enabled: true, addSlidesAfter: 2, addSlidesBefore: 2 }`
  2. Updated src/components/Carousel/Carousel.vue:
     - Imported `Virtual` from 'swiper/modules'
     - Added `:modules="[Virtual]"` to SwiperComponent
  3. Updated src/components/NMCarousel.vue:
     - Imported `Virtual` from 'swiper/modules'
     - Added `:modules="[Virtual]"` to SwiperComponent
     - Added `:virtual-index="itemIndex"` to SwiperSlide
  4. Added/fixed `virtual-index` on SwiperSlide in all child carousel components:
     - src/components/Carousel/MediaCarousel.vue (added virtual-index)
     - src/components/Carousel/PersonCarousel.vue (added virtual-index)
     - src/components/Carousel/ImageCarousel.vue (added virtual-index)
     - src/components/Carousel/SeasonCarousel.vue (added virtual-index)
     - src/components/Carousel/MusicCarousel.vue (fixed: was using carousel index, now uses item index)
     - src/components/Carousel/MusicGenreCarousel.vue (fixed: was using carousel index, now uses item index)
- Notes:
  - Person/Mobile.vue and MusicPlayer/FullPlayer.vue don't use swiperConfig, so are unaffected
  - NMCarousel2.vue uses native CSS scroll (no Swiper), so is unaffected
- Benefits:
  - Swiper only renders visible slides + 2 buffer slides on each side
  - Reduces DOM node count for carousels with many items
  - Improves scroll performance and reduces memory usage for long carousels

### Phase 5.3: Optimize Reactive Dependencies (src/store/ui.ts)
- Status: DONE
- Date: 2026-02-05
- File: src/store/ui.ts
- Changes made:
  1. Imported `shallowRef` from 'vue'
  2. Converted `colorPalette` internal ref (`c`) from `ref` to `shallowRef`:
     - `PaletteColors` is an object that is always replaced entirely, never mutated
     - `shallowRef` skips deep reactivity tracking for the object's properties
     - Initialized with explicit `null` instead of implicit `undefined`
  3. Converted DOM element refs to `shallowRef`:
     - `scrollContainerElement`: holds HTMLDivElement, doesn't need deep reactivity
     - `sidebarContainerElement`: holds HTMLElement, doesn't need deep reactivity
- Benefits:
  - Avoids unnecessary deep reactivity proxy creation for PaletteColors objects
  - DOM elements are large objects; shallowRef prevents Vue from traversing their properties
  - Reduces reactivity overhead on every colorPalette update

### Phase 6.1: Enable Compression (vite.config.ts)
- Status: DONE
- Date: 2026-02-05
- File: vite.config.ts
- Changes made:
  1. Installed `vite-plugin-compression` as a dev dependency
  2. Added `import compression from 'vite-plugin-compression'` to vite.config.ts
  3. Added two compression plugin instances to the plugins array:
     - `compression({ algorithm: 'gzip', ext: '.gz' })` for gzip pre-compression
     - `compression({ algorithm: 'brotliCompress', ext: '.br' })` for Brotli pre-compression
  4. Removed the old commented-out `// gzipPlugin()` line
- Benefits:
  - Build output now includes pre-compressed .gz and .br files alongside originals
  - Servers (Cloudflare, Nginx, etc.) can serve pre-compressed files directly without on-the-fly compression
  - Brotli typically achieves 15-25% better compression than gzip for text assets
  - Reduces server CPU usage since compression happens at build time, not per-request

### Phase 6.2: Optimize CSS Delivery (vite.config.ts)
- Status: DONE
- Date: 2026-02-05
- File: vite.config.ts
- Changes made:
  1. Changed `cssMinify: 'esbuild'` to `cssMinify: 'lightningcss'`:
     - lightningcss produces smaller CSS output than esbuild's CSS minifier
     - lightningcss handles vendor prefix insertion, CSS nesting lowering, and syntax lowering
     - Already the default in rolldown-vite 7.3.1 but was overridden to esbuild
     - lightningcss was already installed in node_modules
  2. Added `devSourcemap: false` to the `css` config:
     - Disables CSS source maps in development for faster rebuilds
     - Reduces memory usage during development
  3. Already present (no changes needed):
     - `cssCodeSplit: true` (CSS split per component/route)
     - `scss.api: 'modern-compiler'` (uses modern Dart Sass API)
- Benefits:
  - Smaller CSS output from lightningcss vs esbuild minification
  - Automatic vendor prefixing and syntax lowering handled by lightningcss
  - Faster dev server rebuilds without CSS sourcemap generation

### Phase 6.3: Configure Optimal Caching Headers (public/_headers)
- Status: DONE (already implemented in prior session)
- Date: 2026-02-05
- File: public/_headers
- Already had comprehensive caching headers matching/exceeding PRD requirements:
  - `/` and `/index.html`: no-cache, no-store, must-revalidate
  - `/sw.js` and `/registerSW.js`: no-cache, no-store, must-revalidate
  - `/assets/*`, `/js/*`, `/css/*`, `/img/*`, `/fonts/*`: immutable, 1 year
  - `/manifest.webmanifest`: max-age=0, must-revalidate
  - Font file extensions (`.woff2`, `.woff`, `.ttf`): immutable, 1 year
- Added `/version.json` no-cache header for Phase 8 version checking system

### Phase 8.1: Implement Version-Based Cache Busting
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Updated vite.config.ts:
     - Added `execSync` import from `node:child_process`
     - Added `getGitCommitHash()` helper that reads `git rev-parse --short HEAD`
     - Added `__APP_VERSION__` define (git commit short hash)
     - Added `__BUILD_TIME__` define (ISO timestamp at build time)
     - Kept existing `__BUILD_TIMESTAMP__` and `__BUILD_VERSION__` for backward compatibility
  2. Created src/lib/version.ts:
     - Declares global `__APP_VERSION__` and `__BUILD_TIME__` types
     - Exports `APP_VERSION` and `BUILD_TIME` constants
     - Exports `isOutdated(serverVersion)` comparison utility
  3. Updated public/_headers:
     - Added `/version.json` with `no-cache, no-store, must-revalidate`
- Benefits:
  - Each build is tagged with its git commit hash
  - Runtime code can compare local version against server version
  - version.json endpoint will never be cached by CDN/browser
  - Foundation for Phase 8.2+ version checking and auto-update system

### Phase 8.2: Server Version Check on App Load
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Created src/lib/versionCheck.ts:
     - `checkForUpdates()`: fetches `/version.json` (cache-busted) and compares with `APP_VERSION`
     - `startVersionChecks()`: runs initial check, sets 5-minute interval, checks on tab visibility change
     - `stopVersionChecks()`: cleans up interval and auto-update timeout
     - `forceUpdate()`: triggers SW skip-waiting and reloads for critical updates
     - `showUpdateAvailable()`: adds localized update notification + auto-update after 30 minutes
  2. Created scripts/generate-version.js:
     - ESM script that generates `docs/version.json` with git commit hash, build time, and optional forceUpdate flag
     - Reads `FORCE_UPDATE` env var for critical deployments
  3. Updated package.json:
     - Changed `build` script to `vite build && node scripts/generate-version.js`
     - version.json is now generated after every production build
  4. Updated src/setupApp.ts:
     - Added version check initialization in production (non-dev) builds
     - Version checks start via lazy import in a queueMicrotask (non-blocking)
     - Runs independently of service worker setup (works even without SW)
- Benefits:
  - App detects new deployments every 5 minutes and on tab focus
  - Users see localized update notification with "Update Now" / "Later" options
  - Auto-update triggers after 30 minutes if user ignores notification
  - Force update capability for critical fixes (set FORCE_UPDATE=true at build time)
  - version.json is cache-busted (no-store header already configured in Phase 6.3)

### Phase 8.4: Handle Keycloak Redirect
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Created src/lib/auth/updateState.ts:
     - `setUpdatePending(version)`: stores pending update version in sessionStorage
     - `getUpdatePending()`: retrieves pending update state
     - `clearUpdatePending()`: clears pending update state
     - `checkAndApplyPendingUpdate()`: checks for pending update after redirect, activates waiting SW or reloads
  2. Updated src/lib/versionCheck.ts:
     - Imported `setUpdatePending` from `@/lib/auth/updateState`
     - Added `setUpdatePending(serverVersion.version)` call when a version mismatch is detected
     - This persists the pending update state in sessionStorage before any Keycloak redirect
  3. Updated src/main.ts:
     - After Keycloak callback completes (in `watch(kc.decodedToken)` handler):
     - Lazy-imports and calls `checkAndApplyPendingUpdate()` after `setupApplication()`
     - If a pending update was stored before redirect, it's applied automatically
- Benefits:
  - Update state survives Keycloak redirects (sessionStorage persists across same-origin navigations)
  - User returns from Keycloak login to the latest version automatically
  - No stale content after authentication flow completes
  - Uses lazy import so the module only loads when needed

### Phase 8.7: Update PWA Config for Reliable Updates
- Status: DONE
- Date: 2026-02-05
- File: pwaConfig.ts
- Changes made:
  1. Added `/^\/version\.json$/` to `navigateFallbackDenylist`:
     - Prevents the service worker from serving cached `index.html` when `/version.json` is requested
     - Ensures version check requests always reach the network
  2. Added `globIgnores: ['**/version.json']`:
     - Excludes version.json from the precache manifest generated by workbox
     - version.json is generated post-build and must always be fetched fresh from the server
  3. Already present (no changes needed):
     - `cleanupOutdatedCaches: true` (removes old SW caches on activation)
     - `clientsClaim: true` (new SW takes control of all clients immediately)
     - `skipWaiting: false` (user-controlled updates via prompt)
- Benefits:
  - version.json will never be served from SW cache or precache
  - Combined with the `no-cache` header from Phase 6.3, version checks always get fresh data
  - Outdated caches are automatically cleaned up when a new SW activates
  - Foundation for reliable cache recovery in Phase 8.8

### Phase 8.8: Recovery for Users with Faulty Cache
- Status: DONE
- Date: 2026-02-05
- Changes made:
  1. Created src/lib/chunkErrorRecovery.ts:
     - Listens for `error` and `unhandledrejection` events that indicate chunk loading failures
     - Detects "Loading chunk", "Failed to fetch dynamically imported module", and "Importing a module script failed"
     - On first chunk error: clears all caches, unregisters all service workers, and reloads
     - `hasRecovered` flag prevents infinite reload loops
  2. Created src/lib/cacheMigration.ts:
     - One-time migration for existing users with stale caches
     - Checks localStorage for migration version key (`nomercy_cache_migration`)
     - If migration version doesn't match `v2`: clears all caches, unregisters SWs, reloads
     - Sets migration key after completion to prevent re-running
     - Gracefully handles errors (sets key even on failure to avoid retry loops)
  3. Updated src/main.ts:
     - `setupChunkErrorRecovery()` called immediately at module level (before any dynamic imports)
     - `runCacheMigration()` gates app initialization: only calls `initializeWebApp()` after migration completes
     - If migration triggers a reload, app init is skipped (page will reload)
- Benefits:
  - Users with stale/broken caches get automatic recovery without manual intervention
  - Chunk loading failures (from mismatched hashes after deploy) auto-recover
  - Existing users get a one-time full cache clear on first visit after this deploy
  - No infinite reload loops (recovery flags prevent re-triggering)

## Next Tasks (from PRD)
- Phase 8.3: Generate version.json on Build (DONE as part of 8.2)
- Phase 8.4: Handle Keycloak Redirect (DONE)
- Phase 8.5: Improve Update Notification UX (auto-update timeout - DONE as part of 8.2)
- Phase 8.6: Cloudflare Headers for Cache Control (DONE in Phase 6.3)
- Phase 8.7: Update PWA Config for Reliable Updates (DONE)
- Phase 8.8: Recovery for Users with Faulty Cache (DONE)
- Phase 8.9: Offline Availability
